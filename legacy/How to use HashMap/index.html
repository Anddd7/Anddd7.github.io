<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Anddd7"><title>如何看待代码中滥用HashMap？-知乎问题读后感和相关研究 · Anddd7's Planet</title><meta name="description" content="昨天在知乎上看到了一个问题如何看待代码中滥用HashMap？ .日常工程中使用HashMap确实挺多的 ,简单方便快捷(至少感觉上是这样) ,但越是简单好用的东西 ,底层封装的越复杂 .
跟进去看了一下 ,朱文彬老师进行了比较直观的对比实验 ,我也查阅了其他的资料 ,最后把这个实验扒下来运行了 .
"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/foundation-icons.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/assets/avatar.jpeg" style="width:127px;"><h3 title=""><a href="/">Anddd7's Planet</a></h3><div class="description"><p>Level Up! Programmer~</p></div></div></div><ul class="social-links"><li><a href="http://github.com/Anddd7"><i class="fa fa-github"></i></a></li><li><a href="mailto:liaoad_space@sina.com"><i class="fi-mail"></i></a></li></ul><div class="footer"><span>Theme based on </span><a href="https://github.com/Ben02/hexo-theme-Anatole"> <strong>Anatole</strong></a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/assets/avatar.jpeg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>如何看待代码中滥用HashMap？-知乎问题读后感和相关研究</a></h3></div><div class="post-content"><p>昨天在知乎上看到了一个问题<a href="https://www.zhihu.com/question/28119895" target="_blank" rel="noopener">如何看待代码中滥用HashMap？</a> .日常工程中使用HashMap确实挺多的 ,简单方便快捷(至少感觉上是这样) ,但越是简单好用的东西 ,底层封装的越复杂 .</p>
<p>跟进去看了一下 ,<a href="https://www.zhihu.com/question/28119895/answer/40494358" target="_blank" rel="noopener">朱文彬</a>老师进行了比较直观的对比实验 ,我也查阅了其他的资料 ,最后把这个实验扒下来运行了 .</p>
<h2 id="资料-HashMap的原理研究"><a href="#资料-HashMap的原理研究" class="headerlink" title="资料 HashMap的原理研究"></a>资料 HashMap的原理研究</h2><hr>
<p><strong>1.HashMap的结构 ,数组Col[对应HashCode] + 链表Row[对应数据节点Entry]</strong></p>
<p><code>transient Node&lt;K,V&gt;[] table</code></p>
<hr>
<p><strong>2.设置初始容量(桶/数组的数量 ,默认16) ,负载因子(判定Map满的条件 ,默认0.75)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始容量不能&lt;0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span></span><br><span class="line">                + initialCapacity);</span><br><span class="line">    <span class="comment">//初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//负载因子不能 &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span></span><br><span class="line">                + loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出大于 initialCapacity 的最小2^n值。</span></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) (capacity * loadFactor);</span><br><span class="line">    <span class="comment">//初始化table数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>3.put方法</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">     <span class="comment">//当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因</span></span><br><span class="line">     <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</span><br><span class="line">     <span class="comment">//计算key的hash值</span></span><br><span class="line">     <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">     ------(<span class="number">1</span>)</span><br><span class="line">     <span class="comment">//计算key hash 值在 table 数组中的位置</span></span><br><span class="line">     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">     ------(<span class="number">2</span>)</span><br><span class="line">     <span class="comment">//从i出开始迭代 e,找到 key 保存的位置</span></span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="comment">//判断该条链上是否有hash值相同的(key相同)</span></span><br><span class="line">         <span class="comment">//若存在相同，则直接覆盖value，返回旧value</span></span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">             V oldValue = e.<span class="keyword">value</span>;    <span class="comment">//旧值 = 新值</span></span><br><span class="line">             e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span> oldValue;     <span class="comment">//返回旧值</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//修改次数增加1</span></span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="comment">//将key、value添加至i位置处</span></span><br><span class="line">     addEntry(hash, key, <span class="keyword">value</span>, i);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.1计算hash值/查询对应的数组列表位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp;amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap通过数组加链表 ,<code>如何均匀分布数据?</code></p>
<ul>
<li>排布太紧链表会很长 ,查询效率会变低(顺序查询)</li>
<li>排布太松数组会很大 ,浪费很多空间</li>
</ul>
<p><code>hash</code>+<code>indexFor</code></p>
<ul>
<li>hash是纯数学计算<br></li><li>合理分布数据需要取模 ,indexFor是特殊的”取模”运算  <br><br><ul>- 因为底层桶的大小length是2^n ,<code>length-1 -&gt; 111...111(2进制)</code></ul></li>
<li><code>10110 &amp;amp; 1111 (22 &amp;amp; 15) -&gt; 00110 (6)</code></li>
<li><code>22%16 = 6</code></li>
</ul>
<p><strong>3.2添加节点/相同key替换</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">void</span> <span class="keyword">addEntry(int </span>hash, K key, V value, int <span class="keyword">bucketIndex) </span>&#123;</span><br><span class="line">    //获取<span class="keyword">bucketIndex处的Entry</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">Entry</span>&lt;K, V&gt; e = table[<span class="keyword">bucketIndex];</span></span><br><span class="line"><span class="keyword"> </span>   //将新创建的 <span class="meta">Entry</span> 放入 <span class="keyword">bucketIndex </span>索引处，并让新的 <span class="meta">Entry</span> 指向原来的 <span class="meta">Entry</span> </span><br><span class="line">    table[<span class="keyword">bucketIndex] </span>= new <span class="meta">Entry</span>&lt;K, V&gt;(hash, key, value, e)<span class="comment">;</span></span><br><span class="line">    //若HashMap中元素的个数超过极限了，则容量扩大两倍</span><br><span class="line">    <span class="meta">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>4.get操作</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 若为null，调用getForNullKey方法返回相对应的value</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// 根据该 key 的 hashCode 值计算它的 hash 码  </span></span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="comment">// 取出 table 数组中指定索引处的值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="comment">//若搜索的key与查找的key相同，则返回相对应的value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp; ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || <span class="built_in">key</span>.equals(k)))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>5.扩容机制</strong></p>
<p>随着HashMap中的元素增加，hash冲突的几率也就变高， <br><br>因为数组的长度是固定的。为了提高查询的效率，要对数组进行扩容(元素超过 大小length*负载因子loadFactor)， <br><br>而在HashMap数组扩容之后，最消耗性能的点就出现了： <br><br>原数组中的数据必须重新计算其在新数组中的位置，并put，这就是<code>resize</code>。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果当前的数组长度已经达到最大值，则不在进行调整</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据传入参数的长度定义新的数组</span></span><br><span class="line">    Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">    <span class="comment">//按照新的规则，将旧数组中的元素转移到新数组中</span></span><br><span class="line">    transfer(<span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">    <span class="comment">//更新临界值</span></span><br><span class="line">    threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旧数组中元素往新数组中迁移</span></span><br><span class="line">void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;</span><br><span class="line">    <span class="comment">//旧数组</span></span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="comment">//新数组长度</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;</span><br><span class="line">    <span class="comment">//遍历旧数组</span></span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);<span class="comment">//放在新数组中的index位置</span></span><br><span class="line">                e.next = <span class="keyword">new</span><span class="type">Table</span>[i];<span class="comment">//实现链表结构，新加入的放在链头，之前的的数据放在链尾</span></span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.线程安全</strong></p>
<p>HashMap是线程不安全的 ,因此在多线程应用时 ,可以考虑使用:</p>
<ul>
<li><code>HashTable</code>(同步锁整个table数组 ,效率较低)</li>
<li><code>Collections.synchronizedMap</code>(对每一个方法增加了synchronized ,但并不保证put/get/contain之间的同步)</li>
<li><code>ConcurrentHashMap</code>(同步锁每次只锁一个桶 ,可以多线程同时读写不同桶 ,也保证了put/get同一个桶的同步)</li>
</ul>
<hr>
<h2 id="实验一-Map-List-数组的内存占用情况"><a href="#实验一-Map-List-数组的内存占用情况" class="headerlink" title="实验一 Map/List/数组的内存占用情况"></a>实验一 Map/List/数组的内存占用情况</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sourceCode.javaSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> sourceCode.objMemoryUtil.ObjMemoryCostUtil.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//import static -&gt; 静态导入 ,导入全部(*)或指定的静态方法 ,可以直接使用 ,不用加System.这样的前缀名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：朱文彬</span></span><br><span class="line"><span class="comment"> * 链接：https://www.zhihu.com/question/28119895/answer/40494358</span></span><br><span class="line"><span class="comment"> * 来源：知乎</span></span><br><span class="line"><span class="comment"> * 著作权归作者所有，转载请联系作者获得授权。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对各种map占用的内存大小进行研究</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class HashMapMemoryTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> printSize(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        out.printf(<span class="string">"类型：%s，占用内存：%.2f MB\n"</span>, o.getClass().getSimpleName(), deepSizeOf(o) / <span class="number">1024</span>D / <span class="number">1024</span>D);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">        java.util.Map&lt;<span class="keyword">Object</span>, <span class="keyword">Object</span>&gt; javaUtilHashMap = <span class="keyword">new</span> java.util.<span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilHashMap.put(i, i), i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Java集合框架Koloboke ,目前的版本主要是替换java.util.HashSet和java.util.HashMap</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Koloboke对每个entry使用了更少的内存</span></span><br><span class="line"><span class="comment">         * Koloboke目标是把键和值存储在同一行高速缓存中</span></span><br><span class="line"><span class="comment">         * 所有的方法都经过了实现优化，而不是像AbstractSet类或AbstractMap类那样委托给框架类（Skeleton Class）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        net.openhft.koloboke.collect.<span class="built_in">map</span>.hash.HashIntIntMap openHftHashIntIntMap = net.openhft.koloboke.collect.<span class="built_in">map</span>.hash.HashIntIntMaps.newUpdatableMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; openHftHashIntIntMap.put(i, i), i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        java.util.ArrayList&lt;<span class="keyword">Object</span>&gt; javaUtilArrayList = <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilArrayList.<span class="built_in">add</span>(i), i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] objectArray = <span class="keyword">new</span> Integer[<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; objectArray[i] = i, i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * hppc - High Performance Primitive Collections for Java</span></span><br><span class="line"><span class="comment">         * 对Java的原始集合类型如映射map、集合set、堆栈stack、列表list、队列deque等进行了扩展，提供了更佳的内存利用率，带来了更好的性能。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        com.carrotsearch.hppc.IntArrayList hppcArrayList = <span class="keyword">new</span> com.carrotsearch.hppc.IntArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; hppcArrayList.<span class="built_in">add</span>(i), i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] primitiveArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; primitiveArray[i] = i, i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"java.vm.name="</span> + System.getProperty(<span class="string">"java.vm.name"</span>));</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"java.vm.version="</span> + System.getProperty(<span class="string">"java.vm.version"</span>));</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"容器元素总数："</span> + <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">        printSize(javaUtilHashMap);</span><br><span class="line">        printSize(openHftHashIntIntMap);</span><br><span class="line">        printSize(javaUtilArrayList);</span><br><span class="line">        printSize(hppcArrayList);</span><br><span class="line">        printSize(primitiveArray);</span><br><span class="line">        printSize(objectArray);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">容器元素总数：30000</span><br><span class="line">类型：<span class="selector-tag">HashMap</span>，占用内存：2<span class="selector-class">.08</span> <span class="selector-tag">MB</span></span><br><span class="line">类型：<span class="selector-tag">UpdatableLHashParallelKVIntIntMap</span>，占用内存：0<span class="selector-class">.50</span> <span class="selector-tag">MB</span></span><br><span class="line">类型：<span class="selector-tag">ArrayList</span>，占用内存：0<span class="selector-class">.58</span> <span class="selector-tag">MB</span></span><br><span class="line">类型：<span class="selector-tag">IntArrayList</span>，占用内存：0<span class="selector-class">.17</span> <span class="selector-tag">MB</span></span><br><span class="line">类型：<span class="selector-tag">int</span><span class="selector-attr">[]</span>，占用内存：0<span class="selector-class">.11</span> <span class="selector-tag">MB</span></span><br><span class="line">类型：<span class="selector-tag">Integer</span><span class="selector-attr">[]</span>，占用内存：0<span class="selector-class">.57</span> <span class="selector-tag">MB</span></span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p>内存差异的原因是：</p>
<pre><code> 1. hash中为避免退化为数组（如openhft的实现可以退化为数组）或者链表（java.util.HashMap可能退化为链表)使用的空槽
 1. java.util.HashMap.Entry的额外占用的内存，用于维持链表、内存对齐等
 2. 对象内存占用：在HotSpot 64位jdk中，一个java.lang.Integer占用16字节，一个引用占用4字节，总共20字节，而一个int只占用4字节
</code></pre>
结果分析 :
<pre><code> 1. 处理 `大数据量的默认类型` 时 ,使用个性化的集合类可以减少类型推断 ,节省拆装箱的内存
 2. 数组是较为底层的 ,内存使用上最少 ,但可支持的操作也很少 ,查询效率也不那么好
 3. 但面对数量巨大的key和简单的value来说 ,使用数组太耗费时间
 4. `内存优化` 和 `搜索优化` 不可调和
</code></pre>


<hr>
<h3 id="补充-deepSizeOf-o-利用Instrumentation检测JVM对象大小"><a href="#补充-deepSizeOf-o-利用Instrumentation检测JVM对象大小" class="headerlink" title="补充:deepSizeOf(o) - 利用Instrumentation检测JVM对象大小"></a>补充:deepSizeOf(o) - 利用Instrumentation检测JVM对象大小</h3><blockquote>
<p>朱老师并未在知乎上发布sizeOf工具类的代码 ,因此我在网上找了一个替代的工具类:<a href="http://www.cnblogs.com/yangjiandan/p/3534781.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">如何准确计算Java对象的大小 - 博客园aprogramer</a> .<br>文章内使用了<a href="http://blog.csdn.net/ykdsg/article/details/12080071" target="_blank" rel="noopener">java.lang.instrument.Instrumentation</a> : Java Instrumentation指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序 ,监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等 .<br>最后参考<a href="http://sunqi.iteye.com/blog/1917802" target="_blank" rel="noopener">Java对象占用内存大小</a>的计算方法 ,完整的计算Map和内部引用的所有成员的大小</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sourceCode.objMemoryUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @(#)MemoryCalculator.java    1.0 2010-11-8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright 2010 Richard Chen(utopia_rabbi@sse.buaa.edu.cn) All Rights Reserved.</span></span><br><span class="line"><span class="comment"> * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Instrumentation去检测JVM中的情况 ,还可以分析JVM中加载的所有对象等</span></span><br><span class="line"><span class="comment"> * 1.编写premain函数 ,作为JVM启动时的回调函数 ,注入Instrumentation实例到工具类中</span></span><br><span class="line"><span class="comment"> * 2.编写MANIFEST.MF ,指定Premain-Class的位置</span></span><br><span class="line"><span class="comment"> * 3.单独打包工具类和MANIFEST</span></span><br><span class="line"><span class="comment"> * 4.在使用入口程序设置VM-operation : -javaagent:target/objMemoryUtil.jar ,指定代理的工具类jar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ObjMemoryCostUtil &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM将在启动时通过&#123;@link #premain&#125;初始化此成员变量.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation instrumentation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM在初始化后在调用应用程序main方法前将调用本方法, 本方法中可以写任何main方法中可写的代码.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param agentArgs 命令行传进行来的代理参数, 内部需自行解析.</span></span><br><span class="line"><span class="comment">     * @param inst      JVM注入的句柄.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> premain(String agentArgs, Instrumentation inst) &#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算实例本身占用的内存大小. 注意:</span></span><br><span class="line"><span class="comment">     * 1. 多次调用可能结果不一样, 主要跟实例的状态有关</span></span><br><span class="line"><span class="comment">     * 2. 实例中成员变量如果是reference类型, 则reference所指向的实例占用内存大小不统计在内 (只计算基本类型的成员)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param obj 待计算内存占用大小的实例.</span></span><br><span class="line"><span class="comment">     * @return 内存占用大小, 单位为byte.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> shallowSizeOf(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instrumentation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Instrumentation initialize failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSharedObj(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instrumentation.getObjectSize(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算实例占用的内存大小, 含其成员变量所引用的实例, 递归计算.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param obj 待计算内存占用大小的实例.</span></span><br><span class="line"><span class="comment">     * @return 内存占用大小, 单位为byte.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> deepSizeOf(Object obj) &#123;</span><br><span class="line">        Map calculated = <span class="keyword">new</span> IdentityHashMap();</span><br><span class="line">        Stack unCalculated = <span class="keyword">new</span> Stack();</span><br><span class="line">        unCalculated.<span class="keyword">push</span>(obj);</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            result += doSizeOf(unCalculated, calculated);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!unCalculated.isEmpty());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断obj是否是共享对象. 有些对象, 如interned Strings, Boolean.FALSE和Integer#valueOf()等.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param obj 待判断的对象.</span></span><br><span class="line"><span class="comment">     * @return true, 是共享对象, 否则返回false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isSharedObj(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == ((String) obj).intern());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="keyword">Boolean</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span> || obj == <span class="keyword">Boolean</span>.<span class="keyword">FALSE</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == Integer.valueOf((Integer) obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="keyword">Short</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == <span class="keyword">Short</span>.valueOf((<span class="keyword">Short</span>) obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="keyword">Byte</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == <span class="keyword">Byte</span>.valueOf((<span class="keyword">Byte</span>) obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="keyword">Long</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == <span class="keyword">Long</span>.valueOf((<span class="keyword">Long</span>) obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Character) &#123;</span><br><span class="line">                <span class="keyword">return</span> (obj == Character.valueOf((Character) obj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认是否需计算obj的内存占用, 部分情况下无需计算.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param obj        待判断的对象.</span></span><br><span class="line"><span class="comment">     * @param calculated 已计算过的对象.</span></span><br><span class="line"><span class="comment">     * @return true, 意指无需计算, 否则返回false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isEscaped(Object obj, Map calculated) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> || calculated.containsKey(obj)</span><br><span class="line">                || isSharedObj(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算栈顶对象本身的内存占用.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param unCalculated 待计算内存占用的对象栈.</span></span><br><span class="line"><span class="comment">     * @param calculated   对象图谱中已计算过的对象.</span></span><br><span class="line"><span class="comment">     * @return 栈顶对象本身的内存占用, 单位为byte.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> doSizeOf(Stack unCalculated, Map calculated) &#123;</span><br><span class="line">        Object obj = unCalculated.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (isEscaped(obj, calculated)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Class</span> clazz = obj.getClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz.isArray()) &#123;</span><br><span class="line">            doArraySizeOf(clazz, obj, unCalculated);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">                <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!Modifier.isStatic(field.getModifiers())</span><br><span class="line">                            &amp;amp;&amp;amp; !field.getType().isPrimitive()) &#123;</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            unCalculated.add(field.get(obj));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        calculated.put(obj, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> shallowSizeOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组中的所有元素加入到待计算内存占用的栈中, 等待处理.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param arrayClazz   数组的型别.</span></span><br><span class="line"><span class="comment">     * @param array        数组实例.</span></span><br><span class="line"><span class="comment">     * @param unCalculated 待计算内存占用的对象栈.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> doArraySizeOf(<span class="keyword">Class</span> arrayClazz, Object array,</span><br><span class="line">                                      Stack unCalculated) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!arrayClazz.getComponentType().isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = Array.getLength(array);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                unCalculated.add(Array.get(array, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instrumentation使用方式</p>
<ul>
<li>编写MANIFEST.MF ,指定Premain-Class的位置</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Manifest-Version</span>: 1<span class="selector-class">.0</span></span><br><span class="line"><span class="selector-tag">Premain-Class</span>: <span class="selector-tag">sourceCode</span><span class="selector-class">.objMemoryUtil</span><span class="selector-class">.ObjMemoryCostUtil</span></span><br><span class="line"><span class="selector-tag">Created-By</span>: 1<span class="selector-class">.6</span><span class="selector-class">.0_29</span></span><br></pre></td></tr></table></figure>
<ul>
<li>单独打包ObjMemoryCostUtil类 ,并将MANIFEST加入到Jar(粗浅的学习了下maven打包)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>objMemoryCostUtil<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>objMemoryUtil<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/objMemoryUtil/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span>src/main/java/sourceCode/objMemoryUtil/MANIFEST.MF<span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span><span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在使用的Main函数中设置VM参数 ,指定jar包位置 <code>-javaagent:target/objMemoryUtil.jar</code></li>
</ul>
<p><img alt="这里写图片描述" src="http://img.blog.csdn.net/20170103170518707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTg1ODQwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""></p>
<ul>
<li>运行即可</li>
</ul>
<hr>
<h2 id="实验二-Map-List-数组的put性能"><a href="#实验二-Map-List-数组的put性能" class="headerlink" title="实验二 Map/List/数组的put性能"></a>实验二 Map/List/数组的put性能</h2><blockquote>
<p>这个实现就是通过插入数据 ,计算插入时间</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sourceCode.javaSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：朱文彬</span></span><br><span class="line"><span class="comment"> * 链接：https://www.zhihu.com/question/28119895/answer/40494358</span></span><br><span class="line"><span class="comment"> * 来源：知乎</span></span><br><span class="line"><span class="comment"> * 著作权归作者所有，转载请联系作者获得授权。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对各种map存取时间进行研究</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class HashMapCPUTimeTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算各集合put操作的时间 ,可以设置重复次数取平均</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param type 对象类型</span></span><br><span class="line"><span class="comment">     * @param r    线程所做的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> printTime(Class type, Runnable r) &#123;</span><br><span class="line">        <span class="keyword">double</span> time = timeCall(r, <span class="number">30</span>);</span><br><span class="line">        <span class="built_in">char</span>[] rpad = <span class="string">"                                    "</span>.toCharArray();</span><br><span class="line">        type.getSimpleName().getChars(<span class="number">0</span>, type.getSimpleName().length(), rpad, <span class="number">0</span>);</span><br><span class="line">        out.printf(<span class="string">"类型：%s \t 耗时：%.2g s\n"</span>, <span class="keyword">new</span> <span class="keyword">String</span>(rpad), time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据重复次数 ,计算所花时间的平均值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param call   目标线程</span></span><br><span class="line"><span class="comment">     * @param repeat 重复次数</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> timeCall(Runnable call, <span class="built_in">int</span> repeat) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] a = <span class="keyword">new</span> <span class="keyword">double</span>[repeat];</span><br><span class="line">        setAll(a, i -&gt; timeCall(call));</span><br><span class="line">        <span class="keyword">if</span> (repeat &gt; <span class="number">7</span>) &#123; <span class="comment">//重复次数&gt;7 ,只对中间的60%数据计算平均</span></span><br><span class="line">            <span class="built_in">sort</span>(a);</span><br><span class="line">            <span class="built_in">int</span> i = <span class="built_in">round</span>(repeat * <span class="number">0.2</span>f);</span><br><span class="line">            <span class="keyword">return</span> stream(a, i, repeat - i).average().getAsDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (repeat &gt; <span class="number">3</span>) &#123; <span class="comment">//重复次数&gt;3 ,去掉一个最高分一个最低分 ,剩下的取平均</span></span><br><span class="line">            <span class="built_in">sort</span>(a);</span><br><span class="line">            <span class="keyword">return</span> stream(a, <span class="number">1</span>, repeat - <span class="number">1</span>).average().getAsDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stream(a).average().getAsDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动线程 ,执行put操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param call</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> timeCall(Runnable call) &#123;</span><br><span class="line">        <span class="keyword">long</span> startA = nanoTime();<span class="comment">//System.nanoTime提供基于系统的相对精确的时间 ,类似秒表</span></span><br><span class="line">        <span class="keyword">long</span> start = nanoTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            call.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1E-9</span>d * (<span class="built_in">max</span>(<span class="number">0</span>, nanoTime() - start - (start - startA))); <span class="comment">//1E-9d :1乘以10的-9次方</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">1000000</span>;</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"java.vm.name="</span> + System.getProperty(<span class="string">"java.vm.name"</span>));</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"java.vm.version="</span> + System.getProperty(<span class="string">"java.vm.version"</span>));</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"容器元素总数："</span> + <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">        printTime(java.util.<span class="keyword">HashMap</span>.class, () -&gt; &#123;</span><br><span class="line">            java.util.Map&lt;<span class="keyword">Object</span>, <span class="keyword">Object</span>&gt; javaUtilHashMap = <span class="keyword">new</span> java.util.<span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilHashMap.put(i, i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(java.util.LinkedHashMap.class, () -&gt; &#123;</span><br><span class="line">            java.util.Map&lt;<span class="keyword">Object</span>, <span class="keyword">Object</span>&gt; javaUtilLinkedHashMap = <span class="keyword">new</span> java.util.LinkedHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilLinkedHashMap.put(i, i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(java.util.concurrent.ConcurrentHashMap.class, () -&gt; &#123;</span><br><span class="line">            java.util.Map&lt;<span class="keyword">Object</span>, <span class="keyword">Object</span>&gt; javaUtilLinkedHashMap = <span class="keyword">new</span> java.util.concurrent.ConcurrentHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilLinkedHashMap.put(i, i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(Collections.synchronizedMap(<span class="keyword">new</span> java.util.concurrent.ConcurrentHashMap()).getClass(), () -&gt; &#123;</span><br><span class="line">            java.util.Map&lt;<span class="keyword">Object</span>, <span class="keyword">Object</span>&gt; javaUtilLinkedHashMap = Collections.synchronizedMap(<span class="keyword">new</span> java.util.concurrent.ConcurrentHashMap());</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilLinkedHashMap.put(i, i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(java.util.TreeMap.class, () -&gt; &#123;</span><br><span class="line">            java.util.Map&lt;<span class="keyword">Object</span>, <span class="keyword">Object</span>&gt; javaUtilTreeMap = <span class="keyword">new</span> java.util.TreeMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilTreeMap.put(i, i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(net.openhft.koloboke.collect.<span class="built_in">map</span>.hash.HashIntIntMaps.newUpdatableMap().getClass(), () -&gt; &#123;</span><br><span class="line">            net.openhft.koloboke.collect.<span class="built_in">map</span>.hash.HashIntIntMap openHftHashIntIntMap = net.openhft.koloboke.collect.<span class="built_in">map</span>.hash.HashIntIntMaps.newUpdatableMap();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; openHftHashIntIntMap.put(i, i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(java.util.ArrayList.class, () -&gt; &#123;</span><br><span class="line">            java.util.ArrayList&lt;<span class="keyword">Object</span>&gt; javaUtilArrayList = <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; javaUtilArrayList.<span class="built_in">add</span>(i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(Integer[].class, () -&gt; &#123;</span><br><span class="line">            Integer[] objectArray = <span class="keyword">new</span> Integer[<span class="built_in">size</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; objectArray[i] = i, i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(com.carrotsearch.hppc.IntArrayList.class, () -&gt; &#123;</span><br><span class="line">            com.carrotsearch.hppc.IntArrayList hppcArrayList = <span class="keyword">new</span> com.carrotsearch.hppc.IntArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; hppcArrayList.<span class="built_in">add</span>(i), i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printTime(<span class="built_in">int</span>[].class, () -&gt; &#123;</span><br><span class="line">            <span class="built_in">int</span>[] primitiveArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">size</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; primitiveArray[i] = i, i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>容器元素总数：1000000 <br><br>       类型：HashMap                                  耗时：0.028 s <br><br>       类型：LinkedHashMap                            耗时：0.025 s <br><br>       类型：ConcurrentHashMap                        耗时：0.10 s <br><br>       类型：SynchronizedMap                          耗时：0.091 s <br><br>       类型：TreeMap                                  耗时：0.25 s <br><br>       类型：UpdatableLHashParallelKVIntIntMap        耗时：0.048 s <br><br>       类型：ArrayList                                耗时：0.0063 s <br><br>       类型：Integer[]                                耗时：0.0031 s <br><br>       类型：IntArrayList                             耗时：0.0033 s <br><br>       类型：int[]                                    耗时：0.00064 s</p><p></p>
</blockquote>
<ul>
<li>单纯对Put操作来讲 ,和memory的实验类似 ,越是底层越是简单的结构 ,效率越高像TreeMap耗时是数组的1000倍</li>
<li>但对于一些后续操作 ,排序/get来说 ,TreeMap/HashMap则不知道高到哪里去</li>
<li>所以了解集合类的差异 ,各自的优缺点 ,合理的使用才是最重要的</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-03</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://anddd7.github.io/legacy/How to use HashMap/,Anddd7's Planet,如何看待代码中滥用HashMap？-知乎问题读后感和相关研究,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/legacy/Scala6/" title="Scala学习整理[第十一-十三章 类型+特质和其应用+包][Programming In Scala]">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/legacy/Scala3/" title="Scala学习整理[第三章 入门Ⅱ][Programming In Scala]">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>