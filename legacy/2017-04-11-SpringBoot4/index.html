<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        SpringBoot学习-第四章 SpringMVC基础-[Spring Boot 实战] - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/assets/avatar.jpeg" />
        </div>
        <div class="name">
            <i>Anddd7</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMvc-快速搭建"><span class="toc-text">SpringMvc 快速搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速配置"><span class="toc-text">快速配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页面和Controller"><span class="toc-text">页面和Controller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#部署"><span class="toc-text">部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMvc常用注解"><span class="toc-text">SpringMvc常用注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC基本配置"><span class="toc-text">MVC基本配置</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        SpringBoot学习-第四章 SpringMVC基础-[Spring Boot 实战]
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-01-06 21:20:16</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="SpringMvc-快速搭建"><a href="#SpringMvc-快速搭建" class="headerlink" title="SpringMvc 快速搭建"></a>SpringMvc 快速搭建</h2><ul>
<li>依赖 : 这里直接使用SpringBoot的快速搭建</li>
</ul>
<pre><code>&lt;!-- 包含常用的web/mvc等依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><pre><code>&lt;!-- 用于管理spring相关的依赖版本 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;${spring-boot.version}&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p><li>日志 : Spring4推荐使用logback</li></p>
<p><blockquote><br>简历一个logback.xml文件进行日志配置 ,内容与log4j差不多<br></blockquote></p>
<ul>
<li>页面 : SpringBoot习惯把页面放置在resources下面</li>
</ul>
<p>页面 : SpringBoot习惯把页面放置在resources下面</p>
<h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><p>用SpringBoot(注解风格)配置代替web.xml和spring-mvc.xml</p>
<ul>
<li>web.xml</li>
</ul>
<pre><code>/**
 * @WebApplicationInitializer 用来配置Servlet3.0的接口 ,也就代替了web.xml ,里面配置的内容和xml配置基本一致 ,部署在tomcat时容器会自动寻找并加载这个实现
 * &lt;p&gt;
 * SpringBoot方式启动的话 ,可以通过配置类(类里定义servlet bean ,然后import到Application)
 */
public class WebInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(MvcConfig.class);
        context.setServletContext(servletContext);

        ServletRegistration.Dynamic servlet = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(context));
        servlet.addMapping(&quot;/&quot;);
        servlet.setLoadOnStartup(1);
    }
}
</code></pre><ul>
<li>SpringMvc</li>
</ul>
<pre><code>@Configuration
@EnableWebMvc //开启一些默认配置MessageConverters,ViewResolvers等
@ComponentScan(&quot;demo2.springboot.mvc&quot;)
public class MvcConfig {
    /**
     * 注册视图转换器 ,为mvc返回的页面路径添加前后缀
     */
    @Bean
    public InternalResourceViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix(&quot;/WEB-INF/classes/views/&quot;);
        viewResolver.setSuffix(&quot;.jsp&quot;);
        viewResolver.setViewClass(JstlView.class);
        return viewResolver;
    }
}
</code></pre><h2 id="页面和Controller"><a href="#页面和Controller" class="headerlink" title="页面和Controller"></a>页面和Controller</h2><pre><code>@Controller
public class HelloController {

    @RequestMapping(&quot;/index&quot;)
    public String hello() {
        System.out.println(&quot;进入controller&quot;);
        return &quot;index&quot;;
    }
}
</code></pre><p>省略<code>index.jsp</code></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>SpringBoot(-web)有自带的Tomcat ,先排除再关联Servlet3.0需要的包 <br><br>用Maven打包成war ,部署在tomcat即可</p>
<pre><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre><h2 id="SpringMvc常用注解"><a href="#SpringMvc常用注解" class="headerlink" title="SpringMvc常用注解"></a>SpringMvc常用注解</h2><ul>
<li><code>@Controller</code> 声明控制器Bean ,容器的DispatcherServlet会把控制器和url绑定</li>
<li><code>@RequestMapping</code> 指定访问路径 ,<code>produces</code>可指定返回资源的类型</li>
<li><code>@ResponseBody</code> 支持返回值放在response内 ,用于AJAX返回数据而非页面</li>
<li><code>@RequestBody</code> 允许参数在request内 ,通常处理POST体</li>
<li><code>@PathVarible</code> 接受路径中的参数 ,例如: <code>/user/add/10002</code> -&gt; ( <code>/user/add/{id}</code> ) -&gt; id=10002</li>
<li><code>@RestController</code> 等效 <code>@Controller + @ResponseBody</code></li>
</ul>
<pre><code>@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @RequestMapping(produces = &quot;text/plain;charset=UTF-8&quot;)
    @ResponseBody
    public String index(HttpServletRequest request) {
        return &quot;url:&quot; + request.getRequestURL() + &quot;can access&quot;;
    }

    @RequestMapping(value = &quot;/login/{userId}&quot;, produces = &quot;text/plain;charset=UTF-8&quot;)
    @ResponseBody
    public String demoLogin(@PathVariable Integer userId, HttpServletRequest request) {
        return &quot;url:&quot; + request.getRequestURL() + &quot;can access , id is :&quot; + userId;
    }

    @RequestMapping(value = &quot;/register&quot;, produces = &quot;application/json;charset=UTF-8&quot;)
    @ResponseBody
    public String demoRegister(UserBean user, HttpServletRequest request) {
        return &quot;url:&quot; + request.getRequestURL() + &quot;can access , User:[&quot; + user.getId() + &quot;,&quot; + user.getName() + &quot;]&quot;;
    }

    @RequestMapping(value = {&quot;/name1&quot;, &quot;/name2&quot;}, produces = &quot;application/xml;charset=UTF-8&quot;)
    @ResponseBody
    public String demoMultiPath(HttpServletRequest request) {
        return &quot;url:&quot; + request.getRequestURL() + &quot;can access&quot;;
    }
}
</code></pre><h2 id="MVC基本配置"><a href="#MVC基本配置" class="headerlink" title="MVC基本配置"></a>MVC基本配置</h2><p><li><code>DispatcherServlet</code>通常拦截所有URL ,而静态资源 js/html/css 需要直接访问 ,需要对Mvc进行配置 <br></li></p>
<p><ul>- 静态资源放置在<code>resources</code>(根目录)下 </ul></p>
<ul>
<li>配置类继承<code>WebMvcConfigurerAdapter</code></li>
<li><p>添加静态资源路径 ,覆盖<code>addResourceHandlers(ResourceHandlerRegistry registry)</code>方法</p>
<pre><code>public class MvcConfig extends WebMvcConfigurerAdapter {

  //...
  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
      registry.addResourceHandler(&quot;/assets/**&quot;).addResourceLocations(&quot;classpath:/assets/&quot;);
  }
}
</code></pre></li>
</ul>
<p><li>拦截器配置 <br></li></p>
<p><ul>- 实现<code>HandlerInterceptor</code>接口 或者 继承<code>HandlerInterceptorAdapter</code>类 ,实现自定义拦截器</ul></p>
<ul>
<li><p>在<code>WebMvcConfigurerAdapter</code>中添加interceptor<br><code>`</code><br>public class DemoInterceptor extends HandlerInterceptorAdapter {</p>
<p>  @Override<br>  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; }<br>  @Override<br>  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {}<br>}</p>
</li>
</ul>
<p>public class MvcConfig extends WebMvcConfigurerAdapter {</p>
<pre><code>//...
</code></pre><p>   @Bean<br>   public DemoInterceptor demoInterceptor() {<br>       return new DemoInterceptor();<br>   }<br>   @Override<br>    public void addInterceptors(InterceptorRegistry registry) {<br>      registry.addInterceptor(demoInterceptor());<br>    }<br>}</p>
<pre><code>
&lt;li&gt;ControllerAdvice - 控制器行为总控 (类似AOP) &lt;br/&gt;
&lt;ul&gt;- 使用`@ControllerAdvice`注解一个类
- 注解ControllerAdvice类中的方法 ,对所有`@RequesMapping`的方法生效
</code></pre><p>@ControllerAdvice //注解启动了一个总控的Controller ,里面的方法会应用到所有@RequestMapping方法 ,并根据注解的不同产生不同作用<br>public class DemoControllerAdvice {</p>
<pre><code>@ModelAttribute //在目标方法执行前 , 产生一个对象 , 并setAttribute
public UserBean addAttribute() {
    System.out.println(&quot;============应用到所有@RequestMapping注解方法，在其执行之前把返回值放入Model&quot;);
    return new UserBean(1, &quot;admin&quot;);
}

@InitBinder // 针对WebDataBinder的预处理
public void initBinder(WebDataBinder binder) {
    System.out.println(&quot;============应用到所有@RequestMapping注解方法，在其执行之前初始化数据绑定器&quot;);
}

@ExceptionHandler(NoClassDefFoundError.class)
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public ModelAndView handleException(WebRequest request, NoClassDefFoundError e) {
    System.out.println(&quot;===========应用到所有@RequestMapping注解的方法，在其抛出NoClassDefFoundError异常时执行&quot;);
    ModelAndView modelAndView = new ModelAndView(&quot;error&quot;);
    modelAndView.addObject(&quot;errorMsg&quot;, e.getMessage());
    return modelAndView;
}
</code></pre><p>}</p>
<pre><code>
- 路径参数默认忽略”.”后的 ,例如 /user/{xx.yy} ,接收到的只有 xx , 需要在Mvc配置中手动关闭

</code></pre><p>public class MvcConfig extends WebMvcConfigurerAdapter {<br>    //…<br>    @Override<br>    public void configurePathMatch(PathMatchConfigurer configurer) {<br>        configurer.setUseRegisteredSuffixPatternMatch(false);<br>    }<br>}</p>
<pre><code>
## 文件上传

- 引入commons-fileupload包
- MVC配置对媒体资源的处理
- Controller处理 ,保存收到的文件

</code></pre><p>public class MvcConfig extends WebMvcConfigurerAdapter {</p>
<pre><code>//...

/**
 * 对multipart类型 (文件)的默认处理设置
 * 由commons-upload实现 需要引入
 */
@Bean
public MultipartResolver multipartResolver() {
    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
    multipartResolver.setMaxUploadSize(1000000);
    multipartResolver.setDefaultEncoding(&quot;UTF-8&quot;);
    return multipartResolver;
}
</code></pre><p>}</p>
<p>@Controller<br>@RequestMapping(“/file”)<br>public class FileController {</p>
<pre><code>@RequestMapping(value = &quot;upload&quot;, method = RequestMethod.POST)
@ResponseBody
public String uploadFile(MultipartFile file) {
    try {
        File newFile = new File(&quot;D:/upload/&quot; + file.getOriginalFilename());
        FileUtils.writeByteArrayToFile(newFile, file.getBytes());
        return &quot;上传成功&quot;;
    } catch (Exception e) {
        e.printStackTrace();
        return &quot;上传失败 : &quot; + e.getMessage();
    }
}
</code></pre><p>}</p>
<pre><code>
## MessageCovertor

- Spring内置了很多 ,默认Jackson
- 如果需要自定义 ,继承 AbstractHttpMessageCovertor

## 服务端推送

- Ajax心跳 : 频率不好控制 ,服务器压力
- WebSocket
- 异步等待 ,服务器抓住请求 ,等待推送时再返回(Server Send Event) - 实质还是浏览器不断请求 异步处理

#### SSE : 需要浏览器支持 ,使用SourceEvent去不断地请求服务器(异步 ,监听到返回再进行下一步) ,

</code></pre><p>服务器可以hold这个连接直到合适的时候</p>
<pre><code>
</code></pre><p>@Controller<br>public class SSEController {<br>    @RequestMapping(value = “/push”, produces = “text/event-stream”)<br>    @ResponseBody<br>    public String push() {<br>        Random r = new Random();<br>        try{<br>            Thread.sleep(5000);<br>        }catch (Exception e){<br>            e.printStackTrace();<br>        }<br>        return “data:Testing 1,2,3”+r.nextInt()+”\n\n”;<br>    }<br>}</p>
<pre><code>
</code></pre><p>if (!!window.EventSource) {<br>    //设置连接后端的方法(url)<br>    var source = new EventSource(‘push’);</p>
<pre><code>source.addEventListener(&#39;message&#39;, function (e) {
    //监听正常返回的消息
});

source.addEventListener(&#39;open&#39;, function (e) {
    //监听打开连接时
}, false);

source.addEventListener(&#39;error&#39;, function (e) {
    //监听error
}, false);
</code></pre><p>} </p>
<pre><code>
#### servlet 3.0+ 开启异步方法

- 使用DeferredResult ,异步返回 ,页面使用Ajax循环访问即可

</code></pre><p>/**</p>
<ul>
<li>控制器调用 具有异步特性的service层 ,在调用结束后控制器就完成任务</li>
<li><p>由service(实质上时DeferredResult)去控制何时返回响应给客户端<br>*/<br>@Controller<br>public class AysncController {<br>  @Autowired PushService pushService;</p>
<p>  @RequestMapping(value = “/defer”)<br>  @ResponseBody<br>  public DeferredResult<string> defer() {</string></p>
<pre><code>  return pushService.getAysncUpdate();
</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>@Service<br>public class PushService {<br>    /**</p>
<pre><code> * @DeferredResult 是用来实现异步请求的(业务逻辑耗时很长)
 * 原servlet流程: request-&gt;servlet.service()-&gt;执行业务逻辑(servlet阻塞)-&gt;response
 * 新的servlet流程: request-&gt;创建子线程执行业务逻辑-&gt;servlet结束(但不反悔response)-&gt;子线程结束返回response(子线程中有req,res)
 */
DeferredResult&lt;String&gt; deferredResult;

/**
 * 方法创建了一个新的DeferredResult 并直接返回 ,servlet接受到这个result过后就结束任务并返回线程池
 * 而request和response移交到了DeferredResult内 ,待setResult后 ,才会返回
 */
public DeferredResult&lt;String&gt; getAysncUpdate() {
    deferredResult = new DeferredResult();
    return deferredResult;
}

@Scheduled(fixedDelay = 3000)
public void refresh() {
    deferredResult.setResult(String.valueOf(System.currentTimeMillis()));
}
</code></pre><p>}</p>
<pre><code>
## SpringMVC的测试

- Spring-test + Junit：使用一些模拟的组件对MVC部分进行单元测试

</code></pre><p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = {SpringMVCConfig.class})<br>@WebAppConfiguration(“src/main/resources”)//标示web资源位置，默认webapp，spring一般是resources<br>public class TestControllerIntegrationTests {<br>    private MockMvc mockMvc;//模拟的mvc对象，使用MockMvcBuilders构造</p>
<pre><code>//测试时注入bean和各种模拟的部件
@Autowired private DemoService demoService;
@Autowired WebApplicationContext context;
@Autowired MockHttpSession session;
@Autowired MockHttpServletRequest request;

@Before
public void setUp() {
    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.context)
                                  .build();
}

@Test
public void testNormalController() throws Exception {
    //模拟发送请求
    mockMvc.perform(MockMvcRequestBuilders.get(&quot;/normal&quot;))
           //各种预期结果
           .andExpect(MockMvcResultMatchers.status()
                                           .isOk())
           .andExpect(MockMvcResultMatchers.view()
                                           .name(&quot;index&quot;))
           .andExpect(MockMvcResultMatchers.forwardedUrl(&quot;/WEB-INF/classes/views/index.jsp&quot;))
           .andExpect(MockMvcResultMatchers.model()
                                           .attribute(&quot;msg&quot;, demoService.saySomething()));
}

@Test
public void testRestController() throws Exception {
    mockMvc.perform(MockMvcRequestBuilders.get(&quot;/rest/testRest&quot;))
           .andExpect(MockMvcResultMatchers.status()
                                           .isOk())
           .andExpect(MockMvcResultMatchers.content()
                                           .contentType(&quot;text/plain;charset=UTF-8&quot;))
           .andExpect(MockMvcResultMatchers.content()
                                           .string(demoService.saySomething()));
}
</code></pre><p>}<br><code>`</code></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span> PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span> UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
