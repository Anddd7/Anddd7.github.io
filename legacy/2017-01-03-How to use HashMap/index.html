<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        如何看待代码中滥用HashMap？-知乎问题读后感和相关研究 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/assets/avatar.jpeg" />
        </div>
        <div class="name">
            <i>Anddd7</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#资料-HashMap的原理研究"><span class="toc-text">资料 HashMap的原理研究</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实验一-Map-List-数组的内存占用情况"><span class="toc-text">实验一 Map/List/数组的内存占用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#补充-deepSizeOf-o-利用Instrumentation检测JVM对象大小"><span class="toc-text">补充:deepSizeOf(o) - 利用Instrumentation检测JVM对象大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实验二-Map-List-数组的put性能"><span class="toc-text">实验二 Map/List/数组的put性能</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        如何看待代码中滥用HashMap？-知乎问题读后感和相关研究
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-01-06 21:20:16</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p>昨天在知乎上看到了一个问题<a href="https://www.zhihu.com/question/28119895" target="_blank" rel="noopener">如何看待代码中滥用HashMap？</a> .日常工程中使用HashMap确实挺多的 ,简单方便快捷(至少感觉上是这样) ,但越是简单好用的东西 ,底层封装的越复杂 .</p>
<p>跟进去看了一下 ,<a href="https://www.zhihu.com/question/28119895/answer/40494358" target="_blank" rel="noopener">朱文彬</a>老师进行了比较直观的对比实验 ,我也查阅了其他的资料 ,最后把这个实验扒下来运行了 .</p>
<h2 id="资料-HashMap的原理研究"><a href="#资料-HashMap的原理研究" class="headerlink" title="资料 HashMap的原理研究"></a>资料 HashMap的原理研究</h2><hr>
<p><strong>1.HashMap的结构 ,数组Col[对应HashCode] + 链表Row[对应数据节点Entry]</strong></p>
<p><code>transient Node&lt;K,V&gt;[] table</code></p>
<hr>
<p><strong>2.设置初始容量(桶/数组的数量 ,默认16) ,负载因子(判定Map满的条件 ,默认0.75)</strong></p>
<pre><code>    public HashMap(int initialCapacity, float loadFactor) {
        //初始容量不能&lt;0
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;
                    + initialCapacity);
        //初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        //负载因子不能 &lt; 0
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot;
                    + loadFactor);

        // 计算出大于 initialCapacity 的最小2^n值。
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;

        this.loadFactor = loadFactor;
        //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作
        threshold = (int) (capacity * loadFactor);
        //初始化table数组
        table = new Entry[capacity];
        init();
    }
</code></pre><hr>
<p><strong>3.put方法</strong></p>
<pre><code>    public V put(K key, V value) {
         //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因
         if (key == null)
             return putForNullKey(value);
         //计算key的hash值
         int hash = hash(key.hashCode());
         ------(1)
         //计算key hash 值在 table 数组中的位置
         int i = indexFor(hash, table.length);
         ------(2)
         //从i出开始迭代 e,找到 key 保存的位置
         for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {
             Object k;
             //判断该条链上是否有hash值相同的(key相同)
             //若存在相同，则直接覆盖value，返回旧value
             if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
                 V oldValue = e.value;    //旧值 = 新值
                 e.value = value;
                 e.recordAccess(this);
                 return oldValue;     //返回旧值
             }
         }
         //修改次数增加1
         modCount++;
         //将key、value添加至i位置处
         addEntry(hash, key, value, i);
         return null;
     }
</code></pre><p><strong>3.1计算hash值/查询对应的数组列表位置</strong></p>
<pre><code>    static int hash(int h) {
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }

    static int indexFor(int h, int length) {
        return h &amp;amp; (length - 1);
    }
</code></pre><p>HashMap通过数组加链表 ,<code>如何均匀分布数据?</code></p>
<ul>
<li>排布太紧链表会很长 ,查询效率会变低(顺序查询)</li>
<li>排布太松数组会很大 ,浪费很多空间</li>
</ul>
<p><code>hash</code>+<code>indexFor</code></p>
<ul>
<li>hash是纯数学计算<br></li><li>合理分布数据需要取模 ,indexFor是特殊的”取模”运算  <br><br><ul>- 因为底层桶的大小length是2^n ,<code>length-1 -&gt; 111...111(2进制)</code></ul></li>
<li><code>10110 &amp;amp; 1111 (22 &amp;amp; 15) -&gt; 00110 (6)</code></li>
<li><code>22%16 = 6</code></li>
</ul>
<p><strong>3.2添加节点/相同key替换</strong></p>
<pre><code>    void addEntry(int hash, K key, V value, int bucketIndex) {
        //获取bucketIndex处的Entry
        Entry&lt;K, V&gt; e = table[bucketIndex];
        //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry 
        table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);
        //若HashMap中元素的个数超过极限了，则容量扩大两倍
        if (size++ &gt;= threshold)
            resize(2 * table.length);
    }
</code></pre><hr>
<p><strong>4.get操作</strong></p>
<pre><code>    public V get(Object key) {
        // 若为null，调用getForNullKey方法返回相对应的value
        if (key == null)
            return getForNullKey();
        // 根据该 key 的 hashCode 值计算它的 hash 码  
        int hash = hash(key.hashCode());
        // 取出 table 数组中指定索引处的值
        for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) {
            Object k;
            //若搜索的key与查找的key相同，则返回相对应的value
            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k)))
                return e.value;
        }
        return null;
    }
</code></pre><hr>
<p><strong>5.扩容机制</strong></p>
<p>随着HashMap中的元素增加，hash冲突的几率也就变高， <br><br>因为数组的长度是固定的。为了提高查询的效率，要对数组进行扩容(元素超过 大小length*负载因子loadFactor)， <br><br>而在HashMap数组扩容之后，最消耗性能的点就出现了： <br><br>原数组中的数据必须重新计算其在新数组中的位置，并put，这就是<code>resize</code>。</p>
<pre><code>    void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        //如果当前的数组长度已经达到最大值，则不在进行调整
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }
        //根据传入参数的长度定义新的数组
        Entry[] newTable = new Entry[newCapacity];
        //按照新的规则，将旧数组中的元素转移到新数组中
        transfer(newTable);
        table = newTable;
        //更新临界值
        threshold = (int)(newCapacity * loadFactor);
    }
    //旧数组中元素往新数组中迁移
    void transfer(Entry[] newTable) {
        //旧数组
        Entry[] src = table;
        //新数组长度
        int newCapacity = newTable.length;
        //遍历旧数组
        for (int j = 0; j &lt; src.length; j++) {
            Entry&lt;K,V&gt; e = src[j];
            if (e != null) {
                src[j] = null;
                do {
                    Entry&lt;K,V&gt; next = e.next;
                    int i = indexFor(e.hash, newCapacity);//放在新数组中的index位置
                    e.next = newTable[i];//实现链表结构，新加入的放在链头，之前的的数据放在链尾
                    newTable[i] = e;
                    e = next;
                } while (e != null);
            }
        }

    }
</code></pre><p><strong>6.线程安全</strong></p>
<p>HashMap是线程不安全的 ,因此在多线程应用时 ,可以考虑使用:</p>
<ul>
<li><code>HashTable</code>(同步锁整个table数组 ,效率较低)</li>
<li><code>Collections.synchronizedMap</code>(对每一个方法增加了synchronized ,但并不保证put/get/contain之间的同步)</li>
<li><code>ConcurrentHashMap</code>(同步锁每次只锁一个桶 ,可以多线程同时读写不同桶 ,也保证了put/get同一个桶的同步)</li>
</ul>
<hr>
<h2 id="实验一-Map-List-数组的内存占用情况"><a href="#实验一-Map-List-数组的内存占用情况" class="headerlink" title="实验一 Map/List/数组的内存占用情况"></a>实验一 Map/List/数组的内存占用情况</h2><pre><code>package sourceCode.javaSE;

import static sourceCode.objMemoryUtil.ObjMemoryCostUtil.*;

//import static -&gt; 静态导入 ,导入全部(*)或指定的静态方法 ,可以直接使用 ,不用加System.这样的前缀名
import static java.lang.System.out;

/**
 * 作者：朱文彬
 * 链接：https://www.zhihu.com/question/28119895/answer/40494358
 * 来源：知乎
 * 著作权归作者所有，转载请联系作者获得授权。
 * &lt;p&gt;
 * 对各种map占用的内存大小进行研究
 */
public class HashMapMemoryTest {

    static void printSize(Object o) {
        out.printf(&quot;类型：%s，占用内存：%.2f MB\n&quot;, o.getClass().getSimpleName(), deepSizeOf(o) / 1024D / 1024D);
    }

    public static void main(String[] args) throws Throwable {

        int size = 30000;

        java.util.Map&lt;Object, Object&gt; javaUtilHashMap = new java.util.HashMap&lt;&gt;();
        for (int i = 0; i &lt; size; javaUtilHashMap.put(i, i), i++) {
        }

        /**
         * Java集合框架Koloboke ,目前的版本主要是替换java.util.HashSet和java.util.HashMap
         *
         * Koloboke对每个entry使用了更少的内存
         * Koloboke目标是把键和值存储在同一行高速缓存中
         * 所有的方法都经过了实现优化，而不是像AbstractSet类或AbstractMap类那样委托给框架类（Skeleton Class）
         */
        net.openhft.koloboke.collect.map.hash.HashIntIntMap openHftHashIntIntMap = net.openhft.koloboke.collect.map.hash.HashIntIntMaps.newUpdatableMap();
        for (int i = 0; i &lt; size; openHftHashIntIntMap.put(i, i), i++) {
        }

        java.util.ArrayList&lt;Object&gt; javaUtilArrayList = new java.util.ArrayList&lt;&gt;();
        for (int i = 0; i &lt; size; javaUtilArrayList.add(i), i++) {
        }

        Integer[] objectArray = new Integer[size];
        for (int i = 0; i &lt; size; objectArray[i] = i, i++) {
        }

        /**
         * hppc - High Performance Primitive Collections for Java
         * 对Java的原始集合类型如映射map、集合set、堆栈stack、列表list、队列deque等进行了扩展，提供了更佳的内存利用率，带来了更好的性能。
         */
        com.carrotsearch.hppc.IntArrayList hppcArrayList = new com.carrotsearch.hppc.IntArrayList();
        for (int i = 0; i &lt; size; hppcArrayList.add(i), i++) {
        }

        int[] primitiveArray = new int[size];
        for (int i = 0; i &lt; size; primitiveArray[i] = i, i++) {
        }

        out.println(&quot;java.vm.name=&quot; + System.getProperty(&quot;java.vm.name&quot;));
        out.println(&quot;java.vm.version=&quot; + System.getProperty(&quot;java.vm.version&quot;));
        out.println(&quot;容器元素总数：&quot; + size);

        printSize(javaUtilHashMap);
        printSize(openHftHashIntIntMap);
        printSize(javaUtilArrayList);
        printSize(hppcArrayList);
        printSize(primitiveArray);
        printSize(objectArray);  
    }
}
</code></pre><pre><code>容器元素总数：30000
类型：HashMap，占用内存：2.08 MB
类型：UpdatableLHashParallelKVIntIntMap，占用内存：0.50 MB
类型：ArrayList，占用内存：0.58 MB
类型：IntArrayList，占用内存：0.17 MB
类型：int[]，占用内存：0.11 MB
类型：Integer[]，占用内存：0.57 MB
</code></pre><blockquote>
</blockquote>
<p>内存差异的原因是：</p>
<pre><code> 1. hash中为避免退化为数组（如openhft的实现可以退化为数组）或者链表（java.util.HashMap可能退化为链表)使用的空槽
 1. java.util.HashMap.Entry的额外占用的内存，用于维持链表、内存对齐等
 2. 对象内存占用：在HotSpot 64位jdk中，一个java.lang.Integer占用16字节，一个引用占用4字节，总共20字节，而一个int只占用4字节
</code></pre>
结果分析 :
<pre><code> 1. 处理 `大数据量的默认类型` 时 ,使用个性化的集合类可以减少类型推断 ,节省拆装箱的内存
 2. 数组是较为底层的 ,内存使用上最少 ,但可支持的操作也很少 ,查询效率也不那么好
 3. 但面对数量巨大的key和简单的value来说 ,使用数组太耗费时间
 4. `内存优化` 和 `搜索优化` 不可调和
</code></pre>


<hr>
<h3 id="补充-deepSizeOf-o-利用Instrumentation检测JVM对象大小"><a href="#补充-deepSizeOf-o-利用Instrumentation检测JVM对象大小" class="headerlink" title="补充:deepSizeOf(o) - 利用Instrumentation检测JVM对象大小"></a>补充:deepSizeOf(o) - 利用Instrumentation检测JVM对象大小</h3><blockquote>
<p>朱老师并未在知乎上发布sizeOf工具类的代码 ,因此我在网上找了一个替代的工具类:<a href="http://www.cnblogs.com/yangjiandan/p/3534781.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">如何准确计算Java对象的大小 - 博客园aprogramer</a> .<br>文章内使用了<a href="http://blog.csdn.net/ykdsg/article/details/12080071" target="_blank" rel="noopener">java.lang.instrument.Instrumentation</a> : Java Instrumentation指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序 ,监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等 .<br>最后参考<a href="http://sunqi.iteye.com/blog/1917802" target="_blank" rel="noopener">Java对象占用内存大小</a>的计算方法 ,完整的计算Map和内部引用的所有成员的大小</p>
</blockquote>
<pre><code>package sourceCode.objMemoryUtil;

/*
 * @(#)MemoryCalculator.java    1.0 2010-11-8
 *
 * Copyright 2010 Richard Chen(utopia_rabbi@sse.buaa.edu.cn) All Rights Reserved.
 * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

import java.lang.instrument.Instrumentation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.*;

/**
 * 利用Instrumentation去检测JVM中的情况 ,还可以分析JVM中加载的所有对象等
 * 1.编写premain函数 ,作为JVM启动时的回调函数 ,注入Instrumentation实例到工具类中
 * 2.编写MANIFEST.MF ,指定Premain-Class的位置
 * 3.单独打包工具类和MANIFEST
 * 4.在使用入口程序设置VM-operation : -javaagent:target/objMemoryUtil.jar ,指定代理的工具类jar
 */
public class ObjMemoryCostUtil {
    /**
     * JVM将在启动时通过{@link #premain}初始化此成员变量.
     */
    private static Instrumentation instrumentation = null;


    /**
     * JVM在初始化后在调用应用程序main方法前将调用本方法, 本方法中可以写任何main方法中可写的代码.
     *
     * @param agentArgs 命令行传进行来的代理参数, 内部需自行解析.
     * @param inst      JVM注入的句柄.
     */
    public static void premain(String agentArgs, Instrumentation inst) {
        instrumentation = inst;
    }

    /**
     * 计算实例本身占用的内存大小. 注意:
     * 1. 多次调用可能结果不一样, 主要跟实例的状态有关
     * 2. 实例中成员变量如果是reference类型, 则reference所指向的实例占用内存大小不统计在内 (只计算基本类型的成员)
     *
     * @param obj 待计算内存占用大小的实例.
     * @return 内存占用大小, 单位为byte.
     */
    public static long shallowSizeOf(Object obj) {
        if (instrumentation == null) {
            throw new IllegalStateException(&quot;Instrumentation initialize failed&quot;);
        }
        if (isSharedObj(obj)) {
            return 0;
        }
        return instrumentation.getObjectSize(obj);
    }

    /**
     * 计算实例占用的内存大小, 含其成员变量所引用的实例, 递归计算.
     *
     * @param obj 待计算内存占用大小的实例.
     * @return 内存占用大小, 单位为byte.
     */
    public static long deepSizeOf(Object obj) {
        Map calculated = new IdentityHashMap();
        Stack unCalculated = new Stack();
        unCalculated.push(obj);
        long result = 0;
        do {
            result += doSizeOf(unCalculated, calculated);
        } while (!unCalculated.isEmpty());
        return result;
    }

    /**
     * 判断obj是否是共享对象. 有些对象, 如interned Strings, Boolean.FALSE和Integer#valueOf()等.
     *
     * @param obj 待判断的对象.
     * @return true, 是共享对象, 否则返回false.
     */
    private static boolean isSharedObj(Object obj) {
        if (obj instanceof Comparable) {
            if (obj instanceof Enum) {
                return true;
            } else if (obj instanceof String) {
                return (obj == ((String) obj).intern());
            } else if (obj instanceof Boolean) {
                return (obj == Boolean.TRUE || obj == Boolean.FALSE);
            } else if (obj instanceof Integer) {
                return (obj == Integer.valueOf((Integer) obj));
            } else if (obj instanceof Short) {
                return (obj == Short.valueOf((Short) obj));
            } else if (obj instanceof Byte) {
                return (obj == Byte.valueOf((Byte) obj));
            } else if (obj instanceof Long) {
                return (obj == Long.valueOf((Long) obj));
            } else if (obj instanceof Character) {
                return (obj == Character.valueOf((Character) obj));
            }
        }
        return false;
    }

    /**
     * 确认是否需计算obj的内存占用, 部分情况下无需计算.
     *
     * @param obj        待判断的对象.
     * @param calculated 已计算过的对象.
     * @return true, 意指无需计算, 否则返回false.
     */
    private static boolean isEscaped(Object obj, Map calculated) {
        return obj == null || calculated.containsKey(obj)
                || isSharedObj(obj);
    }

    /**
     * 计算栈顶对象本身的内存占用.
     *
     * @param unCalculated 待计算内存占用的对象栈.
     * @param calculated   对象图谱中已计算过的对象.
     * @return 栈顶对象本身的内存占用, 单位为byte.
     */
    private static long doSizeOf(Stack unCalculated, Map calculated) {
        Object obj = unCalculated.pop();
        if (isEscaped(obj, calculated)) {
            return 0;
        }
        Class clazz = obj.getClass();
        if (clazz.isArray()) {
            doArraySizeOf(clazz, obj, unCalculated);
        } else {
            while (clazz != null) {
                Field[] fields = clazz.getDeclaredFields();
                for (Field field : fields) {
                    if (!Modifier.isStatic(field.getModifiers())
                            &amp;amp;&amp;amp; !field.getType().isPrimitive()) {
                        field.setAccessible(true);
                        try {
                            unCalculated.add(field.get(obj));
                        } catch (IllegalAccessException ex) {
                            throw new RuntimeException(ex);
                        }
                    }
                }
                clazz = clazz.getSuperclass();
            }
        }
        calculated.put(obj, null);
        return shallowSizeOf(obj);
    }

    /**
     * 将数组中的所有元素加入到待计算内存占用的栈中, 等待处理.
     *
     * @param arrayClazz   数组的型别.
     * @param array        数组实例.
     * @param unCalculated 待计算内存占用的对象栈.
     */
    private static void doArraySizeOf(Class arrayClazz, Object array,
                                      Stack unCalculated) {
        if (!arrayClazz.getComponentType().isPrimitive()) {
            int length = Array.getLength(array);
            for (int i = 0; i &lt; length; i++) {
                unCalculated.add(Array.get(array, i));
            }
        }
    }
}
</code></pre><p>Instrumentation使用方式</p>
<ul>
<li>编写MANIFEST.MF ,指定Premain-Class的位置</li>
</ul>
<pre><code>Manifest-Version: 1.0
Premain-Class: sourceCode.objMemoryUtil.ObjMemoryCostUtil
Created-By: 1.6.0_29
</code></pre><ul>
<li>单独打包ObjMemoryCostUtil类 ,并将MANIFEST加入到Jar(粗浅的学习了下maven打包)</li>
</ul>
<pre><code>&lt;plugin&gt;
    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;objMemoryCostUtil&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;jar&lt;/goal&gt;
            &lt;/goals&gt;
                &lt;phase&gt;package&lt;/phase&gt;
            &lt;configuration&gt;
                &lt;finalName&gt;objMemoryUtil&lt;/finalName&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/objMemoryUtil/**&lt;/include&gt;
                &lt;/includes&gt;
                &lt;archive&gt;
                    &lt;manifestFile&gt;src/main/java/sourceCode/objMemoryUtil/MANIFEST.MF&lt;/manifestFile&gt;
                    &lt;manifest&gt;&lt;addClasspath&gt;true&lt;/addClasspath&gt;&lt;/manifest&gt;
                &lt;/archive&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre><ul>
<li>在使用的Main函数中设置VM参数 ,指定jar包位置 <code>-javaagent:target/objMemoryUtil.jar</code></li>
</ul>
<p><img alt="这里写图片描述" src="http://img.blog.csdn.net/20170103170518707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTg1ODQwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""></p>
<ul>
<li>运行即可</li>
</ul>
<hr>
<h2 id="实验二-Map-List-数组的put性能"><a href="#实验二-Map-List-数组的put性能" class="headerlink" title="实验二 Map/List/数组的put性能"></a>实验二 Map/List/数组的put性能</h2><blockquote>
<p>这个实现就是通过插入数据 ,计算插入时间</p>
</blockquote>
<pre><code>package sourceCode.javaSE;

import java.util.Collections;

import static java.lang.Math.*;
import static java.lang.System.*;
import static java.util.Arrays.*;

/**
 * 作者：朱文彬
 * 链接：https://www.zhihu.com/question/28119895/answer/40494358
 * 来源：知乎
 * 著作权归作者所有，转载请联系作者获得授权。
 * &lt;p&gt;
 * 对各种map存取时间进行研究
 */

public class HashMapCPUTimeTest {

    /**
     * 计算各集合put操作的时间 ,可以设置重复次数取平均
     *
     * @param type 对象类型
     * @param r    线程所做的操作
     */
    static void printTime(Class type, Runnable r) {
        double time = timeCall(r, 30);
        char[] rpad = &quot;                                    &quot;.toCharArray();
        type.getSimpleName().getChars(0, type.getSimpleName().length(), rpad, 0);
        out.printf(&quot;类型：%s \t 耗时：%.2g s\n&quot;, new String(rpad), time);
    }

    /**
     * 根据重复次数 ,计算所花时间的平均值
     *
     * @param call   目标线程
     * @param repeat 重复次数
     * @return
     */
    public static double timeCall(Runnable call, int repeat) {
        double[] a = new double[repeat];
        setAll(a, i -&gt; timeCall(call));
        if (repeat &gt; 7) { //重复次数&gt;7 ,只对中间的60%数据计算平均
            sort(a);
            int i = round(repeat * 0.2f);
            return stream(a, i, repeat - i).average().getAsDouble();
        }
        if (repeat &gt; 3) { //重复次数&gt;3 ,去掉一个最高分一个最低分 ,剩下的取平均
            sort(a);
            return stream(a, 1, repeat - 1).average().getAsDouble();
        }
        return stream(a).average().getAsDouble();
    }

    /**
     * 启动线程 ,执行put操作
     *
     * @param call
     * @return
     */
    public static double timeCall(Runnable call) {
        long startA = nanoTime();//System.nanoTime提供基于系统的相对精确的时间 ,类似秒表
        long start = nanoTime();
        try {
            call.run();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return 1E-9d * (max(0, nanoTime() - start - (start - startA))); //1E-9d :1乘以10的-9次方
    }


    public static void main(String[] args) throws Throwable {
        int size = 1000000;
        out.println(&quot;java.vm.name=&quot; + System.getProperty(&quot;java.vm.name&quot;));
        out.println(&quot;java.vm.version=&quot; + System.getProperty(&quot;java.vm.version&quot;));
        out.println(&quot;容器元素总数：&quot; + size);

        printTime(java.util.HashMap.class, () -&gt; {
            java.util.Map&lt;Object, Object&gt; javaUtilHashMap = new java.util.HashMap&lt;&gt;();
            for (int i = 0; i &lt; size; javaUtilHashMap.put(i, i), i++) {
            }
        });

        printTime(java.util.LinkedHashMap.class, () -&gt; {
            java.util.Map&lt;Object, Object&gt; javaUtilLinkedHashMap = new java.util.LinkedHashMap&lt;&gt;();
            for (int i = 0; i &lt; size; javaUtilLinkedHashMap.put(i, i), i++) {
            }
        });

        printTime(java.util.concurrent.ConcurrentHashMap.class, () -&gt; {
            java.util.Map&lt;Object, Object&gt; javaUtilLinkedHashMap = new java.util.concurrent.ConcurrentHashMap&lt;&gt;();
            for (int i = 0; i &lt; size; javaUtilLinkedHashMap.put(i, i), i++) {
            }
        });

        printTime(Collections.synchronizedMap(new java.util.concurrent.ConcurrentHashMap()).getClass(), () -&gt; {
            java.util.Map&lt;Object, Object&gt; javaUtilLinkedHashMap = Collections.synchronizedMap(new java.util.concurrent.ConcurrentHashMap());
            for (int i = 0; i &lt; size; javaUtilLinkedHashMap.put(i, i), i++) {
            }
        });

        printTime(java.util.TreeMap.class, () -&gt; {
            java.util.Map&lt;Object, Object&gt; javaUtilTreeMap = new java.util.TreeMap&lt;&gt;();
            for (int i = 0; i &lt; size; javaUtilTreeMap.put(i, i), i++) {
            }
        });

        printTime(net.openhft.koloboke.collect.map.hash.HashIntIntMaps.newUpdatableMap().getClass(), () -&gt; {
            net.openhft.koloboke.collect.map.hash.HashIntIntMap openHftHashIntIntMap = net.openhft.koloboke.collect.map.hash.HashIntIntMaps.newUpdatableMap();
            for (int i = 0; i &lt; size; openHftHashIntIntMap.put(i, i), i++) {
            }
        });

        printTime(java.util.ArrayList.class, () -&gt; {
            java.util.ArrayList&lt;Object&gt; javaUtilArrayList = new java.util.ArrayList&lt;&gt;();
            for (int i = 0; i &lt; size; javaUtilArrayList.add(i), i++) {
            }
        });

        printTime(Integer[].class, () -&gt; {
            Integer[] objectArray = new Integer[size];
            for (int i = 0; i &lt; size; objectArray[i] = i, i++) {
            }
        });

        printTime(com.carrotsearch.hppc.IntArrayList.class, () -&gt; {
            com.carrotsearch.hppc.IntArrayList hppcArrayList = new com.carrotsearch.hppc.IntArrayList();
            for (int i = 0; i &lt; size; hppcArrayList.add(i), i++) {
            }
        });

        printTime(int[].class, () -&gt; {
            int[] primitiveArray = new int[size];
            for (int i = 0; i &lt; size; primitiveArray[i] = i, i++) {
            }
        });

    }
}
</code></pre><blockquote>
<p>容器元素总数：1000000 <br><br>       类型：HashMap                                  耗时：0.028 s <br><br>       类型：LinkedHashMap                            耗时：0.025 s <br><br>       类型：ConcurrentHashMap                        耗时：0.10 s <br><br>       类型：SynchronizedMap                          耗时：0.091 s <br><br>       类型：TreeMap                                  耗时：0.25 s <br><br>       类型：UpdatableLHashParallelKVIntIntMap        耗时：0.048 s <br><br>       类型：ArrayList                                耗时：0.0063 s <br><br>       类型：Integer[]                                耗时：0.0031 s <br><br>       类型：IntArrayList                             耗时：0.0033 s <br><br>       类型：int[]                                    耗时：0.00064 s</p><p></p>
</blockquote>
<ul>
<li>单纯对Put操作来讲 ,和memory的实验类似 ,越是底层越是简单的结构 ,效率越高像TreeMap耗时是数组的1000倍</li>
<li>但对于一些后续操作 ,排序/get来说 ,TreeMap/HashMap则不知道高到哪里去</li>
<li>所以了解集合类的差异 ,各自的优缺点 ,合理的使用才是最重要的</li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span> PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span> UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
