<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Scala学习整理[第三十章 Actor和并发][Programming In Scala] - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/assets/avatar.jpeg" />
        </div>
        <div class="name">
            <i>Anddd7</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第三十章-Actor和并发"><span class="toc-text">第三十章 Actor和并发</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Scala学习整理[第三十章 Actor和并发][Programming In Scala]
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-01-06 21:20:16</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="第三十章-Actor和并发"><a href="#第三十章-Actor和并发" class="headerlink" title="第三十章 Actor和并发"></a>第三十章 Actor和并发</h2><pre><code>package SecondWithProgrammingInScala

/**
  * Actor和并发
  *
  * Java采用同步 synchronized ,锁的机制能有效的控制共享数据的操作 ,但是也带来一些死锁和效率上的问题 ,非常依赖程序猿的经验
  * Scala提供了一套模型 :actor ,不共享数据 ,依赖消息传递 (scala原生的actor已替换成akka.actor)
  */

import java.util.concurrent.TimeUnit

import akka.actor.{Actor, ActorSystem, Props}

import scala.concurrent.duration.Duration

//样本类 匹配参数
case class Greeting(who: String)

//抽取器 抽取参数
object Talk {
  def unapply(question: String): Option[String] = question match {
    case &quot;hello&quot; =&gt; Option(&quot;hi&quot;)
    case &quot;nice to meet you&quot; =&gt; Option(&quot;nice to meet you ,too&quot;)
    case _ =&gt; Option(&quot;what?&quot;)
  }
}

//构造Actor类 ,定义收到消息的反应
class HelloActor extends Actor {
  def receive = {
    case Greeting(who) =&gt; println(&quot;Welcome ,&quot; + who)
    case Talk(answer) =&gt; println(answer)
    case _ =&gt; &quot;enh?&quot;
  }
}

object ActorTest {
  def main(args: Array[String]): Unit = {
    //构建Actor中心系统 ,Akka系统消耗比较大，一个应用最好只构建一个
    val system = ActorSystem(&quot;HelloSystem&quot;)
    //注册接收器 和 映射的处理类
    val helloActor = system.actorOf(Props[HelloActor], name = &quot;helloActor&quot;)

    helloActor ! Greeting(&quot;liaoad&quot;)
    helloActor ! &quot;hello&quot;
    helloActor ! &quot;how r you&quot;
    helloActor ! &quot;nice to meet you&quot;

  }
}

/**
  * akka 主从actor工作系统
  *
  * 使用多个工作器 计算pi的值
  */

import akka.actor._
import akka.routing.{RoundRobinGroup, RoundRobinPool}

//发送的信息
sealed trait PiMessage

case object Calculate extends PiMessage

//工作内容 ,主-&gt;从(工作器)
case class Work(start: Int, nrOfElements: Int) extends PiMessage

//工作结果 ,从(工作器)-&gt;主
case class Result(value: Double) extends PiMessage

//监听数据 ,主-&gt;从(监听器)
case class PiApproximation(pi: Double, duration: Duration)

//工作Actor
class Worker extends Actor {
  //接受工作 ,回复工作时间
  def receive = {
    case Work(start, nrOfElements) =&gt;
      sender ! Result(calculatePiFor(start, nrOfElements))
  }

  //计算工作时间
  def calculatePiFor(start: Int, nrOfElements: Int): Double = {
    println(&quot;开始计算pi ,当前节点: start[%s]&quot;.format(start))
    var acc = 0.0
    for (i &amp;lt;- start until (start + nrOfElements))
      acc += 4.0 * (1 - (i % 2) * 2) / (2 * i + 1)
    acc
  }
}

//主机Actor
class Master(nrOfWorkers: Int, nrOfMessages: Int, nrOfElements: Int, listener: ActorRef) extends Actor {
  //任务内容总数
  var pi: Double = _
  //已完成数
  var nrOfResults: Int = _
  //开始时间
  val start: Long = System.currentTimeMillis

  //设置路由池
  val workerRouter = context.actorOf(
    RoundRobinPool(nrOfWorkers).props(Props[Worker]), name = &quot;workerRouter&quot;)

  def receive = {
    //执行计算任务 -&gt; 分配任务给worker
    case Calculate =&gt;
      for (i &amp;lt;- 0 until nrOfMessages) workerRouter ! Work(i * nrOfElements, nrOfElements)
    //执行汇总任务 -&gt; 计算结果汇报给listener
    case Result(value) =&gt;
      println(&quot;节点计算结束 ,当前值: pi[%s] ,value[%s]&quot;.format(pi, value))

      pi += value
      nrOfResults += 1
      //任务已完成
      if (nrOfResults == nrOfMessages) {
        listener ! PiApproximation(pi, duration = Duration(System.currentTimeMillis - start, TimeUnit.MICROSECONDS))
        context.stop(self)
      }
  }
}

//监听器
class Listener extends Actor {
  //接受消息 打印结果
  def receive = {
    case PiApproximation(pi, duration) ⇒
      println(&quot;\n\tPi approximation: \t\t%s\n\tCalculation time: \t%s&quot;
        .format(pi, duration))
      context.system.terminate()
  }
}

object Pi extends App {

  //启动任务管理器
  calculate(nrOfWorkers = 4, nrOfElements = 10000, nrOfMessages = 10000)

  def calculate(nrOfWorkers: Int, nrOfElements: Int, nrOfMessages: Int) {
    //创建akka系统
    val system = ActorSystem(&quot;PiSystem&quot;)
    //创建观察者(因为要注入到主actor中)
    val listener = system.actorOf(Props[Listener], name = &quot;listener&quot;)
    //创建主机(主机通过路由 创建从机)
    val master = system.actorOf(Props(new Master(nrOfWorkers, nrOfMessages, nrOfElements, listener)), name = &quot;master&quot;)

    //执行计算任务
    master ! Calculate
  }

  /**
    * 由结果可见 ,通过路由池(类似线程池) ,主机将消息有序的分配给各个工作器
    * 因为actor结构 ,采用消息的分发和收集实现并行 ,消息的接受是有序的 ,达成了同步
    * 各个Woker是交替开始和结束的 ,但只有汇总的时候Pi值才有序的进行变化
    *
    * akka是一个比较有效的并行同步工具 ,现在也已经推广到了Java中
    */
}
</code></pre>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span> PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span> UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
