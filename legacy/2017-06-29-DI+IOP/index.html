<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        依赖注入 - 如何使用反射和注解实现简单的依赖注入 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/assets/avatar.jpeg" />
        </div>
        <div class="name">
            <i>Anddd7</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖注入"><span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何注入"><span class="toc-text">如何注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cute-Koala"><span class="toc-text">Cute Koala</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置文件-使用注解来标识Bean"><span class="toc-text">配置文件 - 使用注解来标识Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#衍生问题"><span class="toc-text">衍生问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Module"><span class="toc-text">创建Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册实例Bean"><span class="toc-text">注册实例Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#衍生问题-1"><span class="toc-text">衍生问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取Bean"><span class="toc-text">获取Bean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他功能"><span class="toc-text">其他功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        依赖注入 - 如何使用反射和注解实现简单的依赖注入
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-01-06 21:20:16</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p>Github源码 - &gt; <a href="https://github.com/Anddd7/cute-koala" target="_blank" rel="noopener">Anddd7/cute-koala</a></p>
<p>Spring Bean 应该是Spring被使用最多的功能 ,通过注解/xml配置 ,可以简化大量的依赖代码 ,同时也提高了效率 .在试用了Guice和阅读了部分Spring BeanFactory的源码后 ,也了解了一部分依赖注入的原理 ,自己写了一个小框架来印证一下.</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖注入 ,也就是所依赖的对象不由自己处理 ,而是由外部系统去分配 .就像排队取餐时 ,不是每个人自己去盛菜 ,而是告诉服务员自己需要什么 ,由服务员准备好给你 .</p>
<p>这样的好处在于 ,我们不再需要 ‘盛菜’(new) 这个动作 ,只需要告诉 ‘服务员’(DI 容器) 我需要 ‘菜’(依赖的对象) 就可以了 . <br><br>对于很多情况下 ,需要的还可能是 ‘扳手’ 这样可复用的工具 ,那么我们就可以避免大量的new动作 ,节省很多对象资源 .</p>
<h2 id="如何注入"><a href="#如何注入" class="headerlink" title="如何注入"></a>如何注入</h2><p>当我们需要使用某个对象时 ,我们会把它引入到类中 :</p>
<pre><code>class A{
    B object;
    void method(){
        object.do();
    }
}
</code></pre><p>直接运行的话 ,object是null ,程序异常 .我们需要在执行method方法前把B的实例(instance)放到object这个位置 .</p>
<ul>
<li>constructor - 通过A的构造器传入 - [必须在A初始化前初始化B]</li>
<li>set - 设置一个set方法 - [需要显式的调用set/使用反射调用set…]</li>
<li>setField - 反射直接设置属性值</li>
</ul>
<p>constructor方式需要分析对象依赖的顺序 ,如果有环 ,那么就会死锁 ; set方法和对象的实例化是分离的 ,如果所依赖的对象还没有实例 ,就等待它实例化后再set到需要的类中 ;后两种都是Spring使用过的方法 ,都是使用反射 ;setField不需要生成set方法 ,代码看起来会清洁一点 .</p>
<p><img alt="这里写图片描述" src="http://img.blog.csdn.net/20170629165431612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTg1ODQwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""></p>
<p>如上图 ,按照配置文件顺序加载 ,如果依赖对象未存在则等待 ,依赖对象实例化后立即回填这个依赖 .</p>
<h1 id="Cute-Koala"><a href="#Cute-Koala" class="headerlink" title="Cute Koala"></a>Cute Koala</h1><p>首先 ,为这个框架取了一个可爱的名字 Github - <a href="https://github.com/Anddd7/cute-koala" target="_blank" rel="noopener">Cute Cute Koala</a> ,然后按照上图的流程进行设计.</p>
<hr>
<h3 id="配置文件-使用注解来标识Bean"><a href="#配置文件-使用注解来标识Bean" class="headerlink" title="配置文件 - 使用注解来标识Bean"></a>配置文件 - 使用注解来标识Bean</h3><p>使用@Module标识的<code>UserModule.class</code>其实就相当于一个配置文件 ,本身没有实际的作用 ,注解看起来更加整洁一些.</p>
<pre><code>@Module //标识这是一个模块 ,不同模块的bean互相独立 
public class UserModule {

  @Koala //标识Bean的注解
  HttpService httpService;

  @Koala(UserServiceImpl.class) //如果Bean是一个接口 ,可以指定其实现 ;同一module内不允许设置不同的实现
  UserService userService;

  @Koala(scope = ScopeEnum.NOSCOPE) //Bean是非单例的
  RandomTool randomTool;
}
</code></pre><p><strong>框架代码:</strong>@Koala注解用来标识Bean的实现(如果声明是Interface) 和 是否单例</p>
<pre><code>public @interface Koala {
  Class&lt;?&gt; value() default Koala.class;
  ScopeEnum scope() default ScopeEnum.SINGLETON;
  enum ScopeEnum {
    SINGLETON, NOSCOPE
  }
}
</code></pre><p>通过读取@Module注解的class文件 ,就可以分析出里面所有的Bean</p>
<h3 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h3><li>嵌套依赖 <br><br>依赖关系一般是多层相互交错的 ,Bean可能依赖另一个Bean ,分析Module Class只是将最表一层的Bean加载到了容器中 ,但他们里面还会有依赖关系的存在 . 如下 ,UserService (实现为UserServiceImpl ) 里面还依赖了其他Bean ,因此我们在扫描Bean的时候需要递归扫描 .</li>

<pre><code>public class UserServiceImpl implements UserService {
  @Koala(UserDaoImpl.class)
  UserDao userDao;

  @Koala(scope = ScopeEnum.NOSCOPE)
  RandomTool randomTool;

  public void welcome() {
    System.out.println(&quot;Welcome,&quot; + userDao.getName());
  }
}
</code></pre><p><strong>框架代码:</strong> 扫描@Module中的@Koala标记 ,注册到当前@Module的Bean容器中 ;扫描Bean中还有没有@Koala标记 .</p>
<pre><code>class ModuleScanner {
  /**
   * 扫描
   */
  private void scanModule(KoalaModule beanModule) {
    log.info(&quot;开始扫描模块:{}&quot;, beanModule.getModuleName());
    scanClass(beanModule, beanModule.moduleClass);
  }

  /**
   * 扫描类 ,方便树型操作
   */
  private void scanClass(KoalaModule beanModule, Class moduleClass) {
    log.info(&quot;开始扫描目标类[{}],路径[{}]&quot;, moduleClass.getSimpleName(), moduleClass.getName());
    Arrays.asList(moduleClass.getDeclaredFields())
        .forEach(field -&gt; scanComponent(beanModule, field));
    log.info(&quot;扫描类[{}]完毕&quot;, moduleClass.getSimpleName());
  }

  /**
   * 扫描需要注入依赖的字段
   */
  private void scanComponent(KoalaModule beanModule, Field field) {
    if (Objects.isNull(field.getAnnotation(Koala.class))) {
      return;
    }

    Class defineType = field.getType();
    Class implementType = field.getAnnotation(Koala.class).value();
    if (implementType.equals(Koala.class)) {
      implementType = defineType;
    }
    Boolean isSingleton = field.getAnnotation(Koala.class).scope().equals(ScopeEnum.SINGLETON);

    log.info(&quot;扫描Bean,声明类型[{}] ,实现类型[{}],是否单例[{}]&quot;, defineType.getName(), implementType.getName(),
        isSingleton);

    beanModule.createBean(defineType, implementType, isSingleton);

    //递归扫描子模块
    log.info(&quot;开始扫描[{}]字段的依赖类[{}]&quot;, field.getName(), implementType.getSimpleName());
    scanClass(beanModule, implementType);
  }
}
</code></pre><h3 id="创建Module"><a href="#创建Module" class="headerlink" title="创建Module"></a>创建Module</h3><p><strong>框架代码:</strong> 通过@Module进行配置 ,然后交给框架的中心控制器<code>KoalaFactory</code>进行扫描 ,就会按照配置生成相应KoalaModule类 ,里面包含Bean容器 ,扫描到的Bean就会进行实例化放入Bean容器 .</p>
<pre><code>public class KoalaFactory {

  @Getter
  private List&lt;Class&gt; moduleList;

  private Map&lt;Class, KoalaModule&gt; moduleMap = new HashMap&lt;&gt;();
  private ModuleScanner scanner = new ModuleScanner();

  //可以切换当前module
  private int index;
  private KoalaModule currentModule;

  public static KoalaFactory of(Class... modules) {
    return new KoalaFactory().build(modules);
  }

  /**
   * 构建
   */
  private KoalaFactory build(Class... moduleClasses) {
    moduleList = Arrays.asList(moduleClasses);
    scanAndBuild(moduleClasses);
    first();//设置第一个注册module为当前使用的module
  }

  /**
   * 扫描器扫描并生成 module ,默认设置第一个module为当前的操作module
   */
  private void scanAndBuild(Class... moduleClasses) {
    for (Class moduleClass : moduleClasses) {
      scanner.createModule(moduleClass)//扫描module
          .ifPresent(beanModule -&gt; moduleMap.put(moduleClass, beanModule));
    }
  }
}
</code></pre><h3 id="注册实例Bean"><a href="#注册实例Bean" class="headerlink" title="注册实例Bean"></a>注册实例Bean</h3><p><strong>框架代码:</strong> 扫描器在扫描到KoalaModule中符合要求的Bean时 ,就会告知KoalaModule注册这个Bean到容器中.</p>
<pre><code>class ModuleScanner {

  /**
   * 创建一个module
   */
  Optional&lt;KoalaModule&gt; createModule(Class moduleClass) {
    if (!isModule(moduleClass)) {
      return Optional.empty();
    }
    KoalaModule newModule = new KoalaModule(moduleClass);
    scanModule(newModule);
    return Optional.of(newModule);
  }

  /**
   * 检查注解标记
   */
  private Boolean isModule(Class moduleClass) {
    return !Objects.isNull(moduleClass.getAnnotationsByType(Module.class));
  }
  //本段代码在前面有
  private void scanComponent(KoalaModule beanModule, Field field) {
    //省略
    log.info(&quot;扫描Bean,声明类型[{}] ,实现类型[{}],是否单例[{}]&quot;,
        defineType.getName(), implementType.getName(),isSingleton);

    beanModule.createBean(defineType, implementType, isSingleton);
    //省略
  }
}
</code></pre><p><strong>框架代码:</strong> KoalaModule会创建一个BeanPool ,由这个缓冲池来管理Bean的存取和依赖关系的解决</p>
<pre><code>beanPool.addBean(defineType, implementType, isSingleton);
</code></pre><p><strong>框架代码:</strong> 使用BeanWrapper包装Bean的Class/instance/是否单例等信息 .</p>
<pre><code>public class BeanWrapper {
  private Class defineType;//声明类型
  private Class implementType;//实例类型
  private Object instance;//实例对象
  private Boolean singleton;

  public static BeanWrapper of(Class classType, Class implementType, Boolean isSingleton) {
    //new + set
    return beanWrapper;
  }

  /**
   * 根据Bean的条件 创建instance
   * - 单例直接生成对象
   * - 非单例存放class ,在getBean时再实例化
   * - 代理对象(Http RPC ,后续说明)
   */
  void initInstance() {
    try {
      if (!singleton) {
        //非单例 ,object存放实现类型 ,getBean时自动实例化
        instance = implementType;
        return;
      }
      //单例的代理接口 ,生成代理对象
      if (!Objects.isNull(defineType.getAnnotation(HttpKoala.class))) {
        instance = HttpProxyBeanFactory.getProxyInstance(defineType);
        return;
      }
      //单例的Class 或 接口 ,实现类直接实例化
      instance = implementType.newInstance();
    } catch (Exception e) {
      log.error(e.getMessage(), e);
    }
  }
}
</code></pre><p><strong>框架代码:</strong> 如果不存在Bean ,则注册Bean放入缓冲池 ;然后检查Bean的依赖关系.</p>
<pre><code>public void addBean(Class defineType, Class implementType, Boolean isSingleton) {
    BeanWrapper beanWrapper = beanCache.get(defineType);
    if (Objects.isNull(beanWrapper)) {
      //创建新的bean放入cache
      beanWrapper = BeanWrapper.of(defineType, implementType, isSingleton);
      beanCache.put(beanWrapper);
    } else {
      beanWrapper.checkConflict(implementType, isSingleton);
    }

    if (beanWrapper.getSingleton()) {
      //检查自身是否依赖其他bean
      checkRelyFrom(beanWrapper, this::waitOrResolveRely);
    } else {
      log.info(&quot;非单例Bean ,获取Bean时再解决依赖&quot;);
    }
    //检查自身是否被其他类依赖
    checkRelyTo(beanWrapper);
  }
</code></pre><h3 id="衍生问题-1"><a href="#衍生问题-1" class="headerlink" title="衍生问题"></a>衍生问题</h3><ul>
<li>依赖解决 ,在BeanPool中设置了2个缓存Map ,一个是放置BeanWrapper的Bean容器 ;一个是依赖关系的管理器 .</li>
</ul>
<pre><code>private final BeanWrapperCache beanCache = new BeanWrapperCache();
//private Map&lt;Class, BeanWrapper&gt; - Class:注册的Bean
private final BeanRelyCache relyCache = new BeanRelyCache();
//private ListMultimap&lt;Class, BeanWrapper&gt; - Class:List&lt;需要Class实例的其他Bean&gt;
</code></pre><p><strong>框架代码:</strong> 检查是否依赖其他对象 -&gt; 内部有没有@Koala标记的Field ; 处理依赖 (有则set/无则等待)</p>
<pre><code>public class BeanPool {
  private void checkRelyFrom(BeanWrapper beanWrapper,
      BiConsumer&lt;BeanWrapper, Field&gt; biConsumer) {

    log.info(&quot;[{}]正在加载 ,检查是否依赖其他对象&quot;, beanWrapper.getImplementType().getName());
    //查看其实现类(也就是对应的实例对象)中是否依赖其他Bean
    Arrays.asList(beanWrapper.getImplementType().getDeclaredFields()).forEach(field -&gt; {
      if (!Objects.isNull(field.getAnnotation(Koala.class))) {
        biConsumer.accept(beanWrapper, field);
      }
    });
  }

 private void waitOrResolveRely(BeanWrapper beanWrapper, Field field) {
    //获取依赖的Bean的实现类型(对应对象的类型)
    Class implementType = field.getAnnotation(Koala.class).value();
    if (implementType.equals(Koala.class)) {
      implementType = field.getType();
    }

    //查看实例是否已存在
    BeanWrapper oldBeanWrapper = beanCache.get(implementType);
    //检查依赖Bean是否已加载 ,未加载则等待加载
    if (Objects.isNull(oldBeanWrapper)) {
      //放入关系池 等待依赖对象
      relyCache.put(implementType, beanWrapper);
    } else {
      //发现依赖对象set到自身(非单例缓存的是class ,需要在get的时候再set)
      if (beanWrapper.getSingleton()) {
        resolveRely(beanWrapper.getInstance(), field, oldBeanWrapper.getInstance());
      }
    }
  }

  private void resolveRely(Object parent, Field field, Object instance) {
    try {
      log.info(&quot;!!!\t\t处理依赖:[{}]已加载到[{}]的[{}]字段中.&quot;, instance.getClass().getSimpleName(),
          parent.getClass().getName(), field.getName());

      field.setAccessible(true);
      field.set(parent, instance);
    } catch (IllegalAccessException e) {
      log.error(e.getMessage(), e);
    }
  }
}
</code></pre><p><strong>框架代码:</strong> 检查是否被其他对象依赖 -&gt; 依赖关系中有没有依赖列表</p>
<pre><code>/**
   * 获取到 #classType 类型的对象 ,开始检索依赖关系并set到对应位置
   */
  private void checkRelyTo(BeanWrapper beanWrapper) {
    log.info(&quot;[{}-{}]正在加载,检查是否被其他对象依赖&quot;, beanWrapper.getDefineType(),
        beanWrapper.getImplementType().getName());

    //检查自身的实现类型是否被其他类需要
    relyCache.get(beanWrapper.getImplementType())
        .forEach(parentBeanWrapper -&gt; {
          Object parent = parentBeanWrapper.getInstance();
          //获取parent中属于bean (class一致) 的field ,把bean的instanceset进去
          CollectionTool.dealFirst(//获取列表的第一个符合要求的元素
              parent.getClass().getDeclaredFields(),
              beanWrapper::matchType,//field的类型与bean一致
              t -&gt; resolveRely(parent, t, beanWrapper.getObjectOfInstance())//resolveRely见上一段代码
          );
        });

    relyCache.remove(beanWrapper.getImplementType());
  }
</code></pre><p><strong>逻辑就和最开始的图上展现的一样 ,有则加载无则等待 ;加载的Bean发现被别人依赖 ,会主动set到需要的地方 .</strong></p>
<h3 id="获取Bean"><a href="#获取Bean" class="headerlink" title="获取Bean"></a>获取Bean</h3><p><strong>框架代码:</strong> 单例的Bean在注册时已经实例化 ,所以直接取instance即可 ;非单例的需要现场newInstance ,如果他依赖了其他单例的Bean ,再现场set一下 ,这样就可以得到符合要求的非单例Bean了 .</p>
<pre><code> public class BeanPool {

  private final BeanWrapperCache beanCache = new BeanWrapperCache();
  private final BeanRelyCache relyCache = new BeanRelyCache();

  /**
   * 获取对应类型的Bean对象
   */
  public &lt;T&gt; T getBean(Class&lt;T&gt; classType) {
    BeanWrapper scope = beanCache.get(classType);
    if (scope.getSingleton()) {
      log.info(&quot;当前Bean是单例,直接返回缓冲池中的对象.&quot;);
      return (T) scope.getInstance();
    }
    try {
      log.info(&quot;当前Bean是非单例的,创建新的对象.&quot;);
      //如果是远程代理的Bean ,直接生成远程代理
      if (classType.isInterface() &amp;amp;&amp;amp; !Objects.isNull(classType.getAnnotation(HttpKoala.class))) {
        return (T) HttpProxyBeanFactory.getProxyInstance(classType);
      }

      T instance = ((Class&lt;T&gt;) scope.getInstance()).newInstance();
      //创建对象时查看内部是否有依赖关系 ,有则set到instance里
      checkRelyFrom(scope, (beanWrapper, field) -&gt;
          resolveRely(instance, field, getBean(field.getType()))
      );
      return instance;
    } catch (Exception e) {
      log.error(e.getMessage(), e);
    }
    return null;
  }
</code></pre><p><strong><em> 一个DI工具就基本成型了 ,测试打印一下 ,嵌套的Bean和容器的快照对比 ,都是正确的 ;单例对象一致 ,非单例为不同对象</em></strong></p>
<pre><code>    KoalaFactory beanFactory = KoalaFactory.of(UserModule.class);
    HttpService httpService = beanFactory.getBean(HttpService.class);
    UserService userService = beanFactory.getBean(UserService.class);
    RandomTool randomTool = beanFactory.getBean(RandomTool.class);
</code></pre><pre><code>通过Factory.getBean
com.koala.services.impl.UserServiceImpl |   com.koala.services.impl.UserServiceImpl@16267862
com.koala.services.impl.UserServiceImpl |   com.koala.services.impl.UserServiceImpl@16267862
com.koala.daos.impl.UserDaoImpl |   com.koala.daos.impl.UserDaoImpl@453da22c
com.koala.daos.impl.UserDaoImpl |   com.koala.daos.impl.UserDaoImpl@453da22c
com.koala.daos.impl.UserDaoImpl |   com.koala.daos.impl.UserDaoImpl@453da22c
com.koala.webservice.HttpService$$EnhancerByCGLIB$$9c1900a1   |   github.koala.webservice.resetful.HttpProxyObject@71248c21
com.koala.utils.RandomTool  |   com.koala.utils.RandomTool@442675e1
com.koala.utils.RandomTool  |   com.koala.utils.RandomTool@6166e06f
容器:
com.koala.utils.RandomTool  |   class com.koala.utils.RandomTool
com.koala.services.impl.UserServiceImpl |   com.koala.services.impl.UserServiceImpl@16267862
com.koala.daos.UserDao  |   com.koala.daos.impl.UserDaoImpl@453da22c
com.koala.services.UserService  |   com.koala.services.impl.UserServiceImpl@16267862
com.koala.webservice.HttpService    |   github.koala.webservice.resetful.HttpProxyObject@71248c21
com.koala.daos.impl.UserDaoImpl |   com.koala.daos.impl.UserDaoImpl@453da22c
</code></pre><hr>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><ul>
<li>模板生成 : 娱乐功能 ,读取yaml配置 生成对应的 Module.java文件</li>
</ul>
<pre><code>modules:
- moduleName: user-http
  packageName: com.koala
  beans:
  - beanName: httpService
    path: com.koala.services.HttpService

  - beanName: userService
    path: com.koala.services.UserService
    implPath: com.koala.services.impl.UserServiceImpl

  - beanName: randomTool
    path: com.koala.utils.RandomTool
    scope: no
</code></pre><p><strong>To</strong></p>
<pre><code>@github.koala.core.annotation.Module
public class UserHttpModule {

    @github.koala.core.annotation.Koala
  HttpService httpService;

    @github.koala.core.annotation.Koala(value = com.koala.services.impl.UserServiceImpl.class)
    com.koala.services.UserService userService;

    @github.koala.core.annotation.Koala(scope = github.koala.core.annotation.Koala.ScopeEnum.NOSCOPE)
    com.koala.utils.RandomTool randomTool;
}
</code></pre><ul>
<li>Http RPC : 对Restful的Http服务做了一个代理</li>
</ul>
<pre><code>@HttpKoala(&quot;http://localhost:9999/api&quot;)
public interface HttpService {

  @HttpKoalaMethod( &quot;/user&quot;)
  User getUser(@HttpKoalaParameter(&quot;name&quot;) String name);

  @HttpKoalaMethod( &quot;/users&quot;)
  User[] getUsers(@HttpKoalaParameter(&quot;names&quot;) String... names);

  @HttpKoalaMethod(value = &quot;/userList&quot;, httpMethod = HttpMethod.POST)
  List&lt;User&gt; getUserList(@HttpKoalaParameter(&quot;names&quot;) List&lt;String&gt; names);

  @HttpKoalaMethod(&quot;/userMap&quot;)
  Map&lt;String, User&gt; getUserMap(@HttpKoalaParameter(&quot;name&quot;) String name);
}
</code></pre><p><strong>框架代码:</strong> 通过<code>@HttpKoala/@HttpKoalaMethod/@HttpKoalaParameter</code>来确定调用的Http URL和方法 ,使用cglib生成了一个代理对象 ,把方法代理成Http调用 .</p>
<pre><code>public class HttpProxyObject implements MethodInterceptor {

  /**
   * 代理方法 ,托管给http完成
   *
   * @param o 当前的对象
   * @param method 调用的目标方法
   * @param args 方法参数
   * @param methodProxy cglib派生的子对象
   */
  @Override
  public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy)
      throws Throwable {
    Instant start = Instant.now();

    //屏蔽toString ,equals等方法
    Object parentMethodResult = checkProxyMethod(method, args);
    if (parentMethodResult != null) {
      return parentMethodResult;
    }
    log.info(&quot;----------------------------------------------&quot;);
    log.info(&quot;[{}]调用远程方法[{}].&quot;, className, method.getName());

    String url = rootUrl + method.getAnnotation(HttpKoalaMethod.class).value();
    HttpMethod httpMethod = method.getAnnotation(HttpKoalaMethod.class).httpMethod();

    //创建请求request
    Request request;
    if (httpMethod.equals(HttpMethod.GET)) {
      request = httpClient.initGet(url + requestParser.formatParameter2Url(method, args));
    } else {
      request = httpClient.initPost(url, requestParser.getMediaType(),
          requestParser.formatParameter2Body(method, args));
    }
    //一个切面 可以检查request
    requestParser.checkRequest(request);

    //执行
    Response response = httpClient.execute(request);

    //解析
    Object result = responseParser.parserResponse(response, method.getReturnType());

    log.info(&quot;[{}]远程方法[{}]代理执行时间:[{}]&quot;, className, method.getName(),
        Duration.between(start, Instant.now()).toMillis());
    log.info(&quot;----------------------------------------------\n&quot;);
    return result;
  }
}
</code></pre><p><strong>框架代码:</strong> Http的请求消息和响应消息都做了一个可替换的parser ,默认是JSON ,只要实现对应的接口 ,在@HttpKoala中设置就可以替换了.</p>
<pre><code>public @interface HttpKoala {
  String value();
  Class responseParser() default JsonResponseParser.class;
  Class requestParser() default JsonRequestParser.class;
}
</code></pre><p><strong>框架代码:</strong> HttpClientPool 是封装的OkHttp ,对外没有依赖 ,比较简洁也很好修改 ; </p>
<pre><code>public class HttpProxyObject implements MethodInterceptor {

  private String className;
  private String rootUrl;

  private AbstractResponseParser responseParser;
  private AbstractRequestParser requestParser;

  private HttpClientPool httpClient = new HttpClientPool();

  /**
   * 创建代理对象 ,添加序列化工具
   */
  HttpProxyObject(Class&lt;?&gt; classType) {
    this.className = classType.getName();
    this.rootUrl = classType.getAnnotation(HttpKoala.class).value();

    //检查解析器
    Class&lt;?&gt; resParserClass = classType.getAnnotation(HttpKoala.class).responseParser();
    Class&lt;?&gt; reqParserClass = classType.getAnnotation(HttpKoala.class).requestParser();
    if (resParserClass.isAssignableFrom(AbstractResponseParser.class) &amp;amp;&amp;amp; reqParserClass
        .isAssignableFrom(AbstractRequestParser.class)) {
      log.error(&quot;对应的消息解析器必须继承自AbstractResponseParser和AbstractRequestParser.&quot;);
      return;
    }

    try {
      responseParser = (AbstractResponseParser) resParserClass.newInstance();
      requestParser = (AbstractRequestParser) reqParserClass.newInstance();
    } catch (Exception e) {
      e.printStackTrace();
    }

    log.info(&quot;生成[{}]远程代理Bean,使用[{}]进行结果解析&quot;, classType.getName(), resParserClass.getName());
  }
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代码还是要多写才行</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span> PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span> UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
